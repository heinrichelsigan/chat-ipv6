<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Area23.At.Framework.Core</name>
    </assembly>
    <members>
        <member name="T:Area23.At.Framework.Core.Cache.RedIs">
            <summary>
            Redis AWS elastic valkey cache singelton connector
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIs.#ctor">
            <summary>
            default parameterless constructor for RedIsValKey cache singleton 
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIs.GetString(System.String,StackExchange.Redis.CommandFlags)">
            <summary>
            GetString gets a string value by redis key
            </summary>
            <param name="redIsKey">key</param>
            <param name="flags"><see cref="T:StackExchange.Redis.CommandFlags"/></param>
            <returns>(<see cref="T:System.String"/>) value for key redIsKey</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Cache.RedIs.SetString(System.String,System.String,System.Nullable{System.TimeSpan},System.Boolean,StackExchange.Redis.When,StackExchange.Redis.CommandFlags)" -->
        <member name="M:Area23.At.Framework.Core.Cache.RedIs.SetKey``1(System.String,``0,System.Nullable{System.TimeSpan},System.Boolean,StackExchange.Redis.When,StackExchange.Redis.CommandFlags)">
            <summary>
            SetKey<typeparamref name="T"/> sets a genric type T with a referenced key
            </summary>
            <typeparam name="T">generic type or class</typeparam>
            <param name="redIsKey">key for cache</param>
            <param name="tValue">Generic value to set</param>
            <param name="expiry"></param>
            <param name="keepTtl"></param>
            <param name="when"></param>
            <param name="flags"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIs.GetKey``1(System.String,StackExchange.Redis.CommandFlags)">
            <summary>
            GetKey<typeparamref name="T"/> gets a generic class type T from redis cache with key
            </summary>
            <typeparam name="T"></typeparam>
            <param name="redIsKey">key</param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIs.DeleteKey(System.String,StackExchange.Redis.CommandFlags)">
            <summary>
            DeleteKey delete entry referenced at key
            </summary>
            <param name="redIsKey">key</param>
            <param name="flags"><see cref="F:StackExchange.Redis.CommandFlags.FireAndForget"/> as default</param>
        </member>
        <member name="T:Area23.At.Framework.Core.Cache.RedIstatic">
            <summary>
            RedIstatic static AWS elastic valkey cache singelton connector
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIstatic.#cctor">
            <summary>
            static ctor for static class RedIstatic 
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIstatic.GetString(System.String,StackExchange.Redis.CommandFlags)">
            <summary>
            GetString gets a string value by redis key
            </summary>
            <param name="redIsKey">key</param>
            <param name="flags"><see cref="T:StackExchange.Redis.CommandFlags"/></param>
            <returns>(<see cref="T:System.String"/>) value for key redIsKey</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Cache.RedIstatic.SetString(System.String,System.String,System.Nullable{System.TimeSpan},System.Boolean,StackExchange.Redis.When,StackExchange.Redis.CommandFlags)" -->
        <member name="M:Area23.At.Framework.Core.Cache.RedIstatic.SetKey``1(System.String,``0,System.Nullable{System.TimeSpan},System.Boolean,StackExchange.Redis.When,StackExchange.Redis.CommandFlags)">
            <summary>
            SetKey<typeparamref name="T"/> sets a genric type T with a referenced key
            </summary>
            <typeparam name="T">generic type or class</typeparam>
            <param name="redIsKey">key for cache</param>
            <param name="tValue">Generic value to set</param>
            <param name="expiry"></param>
            <param name="keepTtl"></param>
            <param name="when"></param>
            <param name="flags"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIstatic.GetKey``1(System.String,StackExchange.Redis.CommandFlags)">
            <summary>
            GetKey<typeparamref name="T"/> gets a generic class type T from redis cache with key
            </summary>
            <typeparam name="T"></typeparam>
            <param name="redIsKey">key</param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Cache.RedIstatic.DeleteKey(System.String,StackExchange.Redis.CommandFlags)">
            <summary>
            DeleteKey delete entry referenced at key
            </summary>
            <param name="redIsKey">key</param>
            <param name="flags"><see cref="F:StackExchange.Redis.CommandFlags.FireAndForget"/> as default</param>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrException">
            <summary>
            CqrException is inherited from <see cref="T:System.ApplicationException"/>
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrChatRoom">
            <summary>
            CqrChatRoom is a contact for CqrJd
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact">
            <summary>
            CqrContact is a contact for CqrJd
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.ChatRuid">
            <summary>
            Chat Room unique id
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.ChatRoomNr">
            <summary>
            ChatRoom number of Chat Room on Sessiopn Server
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.TicksLong">
            <summary>
            List of message indices, which user has already received
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.LastPushed">
            <summary>
            Date, where user pushed last message to server
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.LastPolled">
            <summary>
            DateTime, where user polled last time server
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.#ctor">
            <summary>
            Parameterless default constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.#ctor(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.String,System.String)">
            <summary>
            Constructor only for sending contact to service with null empty picture
            </summary>
            <param name="c"></param>
            <param name="chatRoomNr"></param>
            <param name="hash"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.#ctor(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.String,System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage)">
            <summary>
            constuctor to update local contact on Windows Chat Client, picture will be set again
            </summary>
            <param name="c"></param>
            <param name="chatRoomNr"></param>
            <param name="hash"></param>
            <param name="contactImage"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact.GetRowParams">
            <summary>
            <see cref="!:object[]">RowParams</see> gets an object array of row parameters to show in <see cref="T:System.Windows.Forms.DataGridView"/>
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile">
            <summary>
            Represtents a MimeAttachment
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile.#ctor(System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum)">
            <summary>
            Constructor CqrFile from an json, xml or raw serialized plaintext
            </summary>
            <param name="plainText"></param>
            <param name="msgArt"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile.ToJson">
            <summary>
            Serialize <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile"/> to Json Stting
            </summary>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile.FromJson``1(System.String)">
            <summary>
            Generic method to convert back from json string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="jsonText"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile.GetWebPage">
            <summary>
            Get Html Page embedding CqrFile
            </summary>
            <returns>html as string rendered</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile.GetFileNameContentLength">
            <summary>
            GetFileNameContentLength write <see cref="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile.CqrFileName"/> and <see cref="!:Data.Length"/>
            </summary>
            <returns>CqrFileName + " [" + Data.Length + "]";</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage">
            <summary>
            CqrImage is a image for a <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact"/>
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ImageFileName">
            <summary>
            File Name with extension of Image
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ImageMimeType">
            <summary>
            Mime Type of Image
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ImageData">
            <summary>
            byte[] of Image Raw Data
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ImageBase64">
            <summary>
            Base64 mime encoded string of raw data
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.#ctor" -->
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.#ctor(System.String,System.Byte[])">
            <summary>
            Ctor with filename and byte[] data
            </summary>
            <param name="fileName"></param>
            <param name="data"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.#ctor(System.String,System.String)">
            <summary>
            Ctor with filename and mime encoded base64 string
            </summary>
            <param name="fileName"></param>
            <param name="base64Image"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.#ctor(System.Drawing.Image,System.String)">
            <summary>
            Ctor with <see cref="T:System.Drawing.Image"/> and fileName
            </summary>
            <param name="image"> <see cref="T:System.Drawing.Image"/>  <see cref="T:System.Drawing.Bitmap"/></param>
            <param name="fileName">fileName for the image,
            if fileName is null or empty
            then a name <see cref="!:Extensions.Area23DateTimeWithMillis(DateTime)"/></param> + "_image." + extension based mime type will be given
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ToJson">
            <summary>
            Serializes this <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> to <see cref="T:System.String">serialized json string</see>
            </summary>
            <returns><see cref="T:System.String">serialized json string</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.FromJson(System.String)">
            <summary>
            FromJson deserializes a <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> from serialized json <see cref="T:System.String"/>
            </summary>
            <param name="jsonText">serialized json <see cref="T:System.String"/></param>
            <returns>deserialized  <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ToXml">
            <summary>
            ToXml serializes this <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> to serialized xml <see cref="T:System.String"/>
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.FromXml``1(System.String)" -->
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ToDrawingBitmap">
            <summary>
            ToDrawingBitmap converts this <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> to <see cref="T:System.Drawing.Bitmap"/>
            </summary>
            <returns>transformed see cref="System.Drawing.Bitmap"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.SaveCqrImage(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage,System.String)">
            <summary>
            Saves a <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> to a filepath
            </summary>
            <param name="image"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/></param>
            <param name="directoryPath">full directory and file path</param>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.LoadCqrImage(System.String)">
            <summary>
            LoadCqrImage loads a <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> from filepath
            </summary>
            <param name="imageFilePath">full filepath</param>
            <returns><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/></returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.ToDrawingImage(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage)">
            <summary>
            ToDrawingImage converts a <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> to a <see cref="T:System.Drawing.Image"/>
            </summary>
            <param name="cqrImage"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> to convert</param>
            <returns>converted <see cref="T:System.Drawing.Image"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage.FromDrawingImage(System.Drawing.Image,System.String)">
            <summary>
            FromDrawingImage converts a <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage"/> from a <see cref="T:System.Drawing.Image"/>
            </summary>
            <param name="image"><see cref="T:System.Drawing.Image"/></param>
            <param name="imgName"><see cref="T:System.String">string imgName</see></param>
            <returns><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrImage">converted CqrImage</see></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1">
            <summary>
            Full SrvMsg
            </summary>
            <typeparam name="TC"></typeparam>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1.#ctor(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,`0,System.String,System.String)">
            <summary>
            Please always use this constuctor
            </summary>
            <param name="sender">CqrContact</param>
            <param name="to">CqrContact</param>
            <param name="tc"></param>
            <param name="hash"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1.#ctor(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact[],`0,System.String,System.String)">
            <summary>
            Please always use this constuctor
            </summary>
            <param name="sender">CqrContact</param>
            <param name="tos">Array of CqrContact</param>
            <param name="tc"></param>
            <param name="hash"></param>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent">
            <summary>
            Represtents a MsgContent
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent.Message">
            <summary>
            Message TODO:
            [Obsolete("TODO: remove it with hash at end", false)]
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent.#ctor">
            <summary>
            Parameterless constructor MsgContent
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent.#ctor(System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum)">
            <summary>
            this constructor requires a serialized or rawstring in msg
            </summary>
            <param name="serializedString">serialized string</param>
            <param name="msgArt">Serialization type</param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent.#ctor(System.String,System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum,System.String)">
            <summary>
            this ctor requires a plainstring and serialize it in _rawMessage
            </summary>
            <param name="plainTextMsg">plain text message</param>
            <param name="hash"></param>
            <param name="msgArt"></param>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg">
            <summary>
            Provides abstract base class for secure encrypted message to send to the server or receive from server
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.#ctor(System.String)">
            <summary>
            CqrBaseMsg constructor with srvKey
            </summary>
            <param name="srvKey">server key (normally client ip + secret)</param>
            <exception cref="T:System.ArgumentNullException">thrown, when srvKey is null or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.CqrBaseMsg(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrBaseMsg encrypts a msg 
            </summary>
            <param name="msg">plain text string</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.CqrBaseMsg(System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrBaseMsg encrypts a msg 
            </summary>
            <param name="msg">plain text string</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.CqrBaseMsg(Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrBaseMsg encrypts a msg 
            </summary>
            <param name="msc">plain MsgContent</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.NCqrBaseMsg(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrBaseMsg decryptes an secure encrypted msg 
            </summary>
            <param name="cqrMessage">secure encrypted msg </param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>MsgContent Message plain text decrypted string</returns>
            <exception cref="T:System.InvalidOperationException">will be thrown, 
            if server and client or both side use a different secret key 4 encryption</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.VerificationHash(Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent@)">
            <summary>
            GetVerificationHash gets verification hash
            </summary>
            <param name="decrypted">decrypted text</param>
            <returns>verification hash</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrMsg.BaseMsg.VerifyHash(System.String,System.String)">
            <summary>
            VerifyHash verifies hash against <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.PipeString"/>
            </summary>
            <param name="hash">verification hash parsed out of msg</param>
            <returns>true, if msg could be verified, otherwise false</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSettings.#ctor">
            <summary>
            CqrSettings constructor maybe needed public for NewTonSoftJson serializing object
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSettings.#ctor(System.DateTime)">
            <summary>
            ctor with inital timestamp
            </summary>
            <param name="timeStamp"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSettings.LoadSettings(System.String)">
            <summary>
            loads json serialized Settings data string from 
            <see cref="!:LibPaths.AppDirPath"/> + <see cref="F:Area23.At.Framework.Core.Static.Constants.JSON_SAVE_FILE"/>
            and deserialize it to singleton instance <see cref="T:Area23.At.Framework.Core.CqrXs.CqrSettings"/> of <seealso cref="T:System.Lazy`1"/>
            </summary>
            <param name="jsonFileName">file name (incl. path), that contains serialized <see cref="T:Area23.At.Framework.Core.CqrXs.CqrSettings"/> json</param>
            <returns>singelton <see cref="P:Area23.At.Framework.Core.CqrXs.CqrSettings.Instance"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSettings.SaveSettings(Area23.At.Framework.Core.CqrXs.CqrSettings,System.String)">
            <summary>
            json serializes <see cref="T:Area23.At.Framework.Core.CqrXs.CqrSettings"/> and 
            saves json serialized data string to 
            <see cref="!:LibPaths.AppDirPath"/> + <see cref="F:Area23.At.Framework.Core.Static.Constants.JSON_SAVE_FILE"/>
            </summary>
            <param name="CqrSettings">settings to save</param>
            <param name="jsonFileName">filename (incl. path), where writing serialized <see cref="T:Area23.At.Framework.Core.CqrXs.CqrSettings"/> json</param>
            <returns>true on successfully save</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg">
            <summary>
            Provides a secure encrypted message to send to the server or receive from server
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.#ctor(System.String)">
            <summary>
            CqrServerMsg constructor with srvKey
            </summary>
            <param name="srvKey">server key (normally client ip + secret)</param>
            <exception cref="T:System.ArgumentNullException">thrown, when srvKey is null or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.CqrPeerMsg(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrPeerMsg encrypts a msg 
            </summary>
            <param name="msg">plain text string</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="!:CipherPipe"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.CqrFile(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrFile, encrypts a attached file persisted in <see cref="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.CqrFile(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)"/>
            </summary>
            <param name="cqrFile">file to encrypt</param>
            <param name="msgType"></param>
            <param name="encType"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.NCqrPeerMsg(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrPeerMsg decryptes an secure encrypted msg 
            </summary>
            <param name="cqrMessage">secure encrypted msg </param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.MsgContent"/> Message plain text decrypted string</returns>
            <exception cref="T:System.InvalidOperationException">will be thrown, 
            if server and client or both side use a different secret key 4 encryption</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.NCqrFile(System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrFile decrypts a encrypted file
            </summary>
            <param name="cqrMessage">encrypted message</param>
            <param name="msgType"></param>
            <param name="encType"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.Send_CqrPeerMsg(System.String,System.Net.IPAddress,System.Int32,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Send_CqrPeerMsg, sends a plain-text message to peer 2 peer partner
            </summary>
            <param name="msg">message to send</param>
            <param name="peerIp">peer partner ip address</param>
            <param name="serverPort">tcp server port</param>
            <param name="encodingType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>response string</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.CqrXs.CqrSrv.Peer2PeerMsg.Send_CqrFile(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrFile,System.Net.IPAddress,System.Int32,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)" -->
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrSrv.SelfCryptMsg">
            <summary>
            Provides a secure encrypted message to send to the server or receive from server
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SelfCryptMsg.#ctor(System.String)">
            <summary>
            SelfCryptMsg constructor with srvKey
            </summary>
            <param name="srvKey">server key (normally client ip + secret)</param>
            <exception cref="T:System.ArgumentNullException">thrown, when srvKey is null or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SelfCryptMsg.CqrSelfMsg(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrPeerMsg encrypts a msg 
            </summary>
            <param name="msg">plain text string</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="!:CipherPipe"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SelfCryptMsg.NCqrSelfMsg(System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgEnum@,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrPeerMsg decryptes an secure encrypted msg 
            </summary>
            <param name="cqrMessage">secure encrypted msg </param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns><see cref="T:System.String"/> Message plain text decrypted string</returns>
            <exception cref="T:System.InvalidOperationException">will be thrown, 
            if server and client or both side use a different secret key 4 encryption</exception>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg">
            <summary>
            Provides a secure encrypted message to send to the server or receive from server
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.#ctor(System.String,System.String)">
            <summary>
            CqrServerMsg constructor with srvKey
            </summary>
            <param name="srvKey">server key (normally client ip + secret)</param>
            <exception cref="T:System.ArgumentNullException">thrown, when srvKey is null or <see cref="F:System.String.Empty"/></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.#ctor(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.String,System.String)" -->
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.CqrSrvMsg(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrSrvMsg
            </summary>
            <param name="sender"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact"/></param>
            <param name="receipient"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact"/></param>
            <param name="msg">plain text string</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe"/></returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.CqrSrvMsg``1(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,``0,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrSrvMsg generic
            </summary>
            <typeparam name="T">generic content of message</typeparam>
            <param name="sender"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact"/></param>
            <param name="receipient"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact"/></param>
            <param name="tcontent">generic content will be mapped to msg</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe"/></returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.NCqrSrvMsg``1(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrSrvMsg decryptes an secure encrypted msg 
            </summary>
            <param name="cqrMessage">secure encrypted msg </param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/></returns>
            <exception cref="T:System.InvalidOperationException">will be thrown, 
            if server and client or both side use a different secret key 4 encryption</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.NCqrSrvMsgSC``1(System.String,Area23.At.Framework.Core.CqrXs.CqrMsg.MsgKind,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrSrvMsgT decryptes an secure encrypted generic msg 
            </summary>
            <typeparam name="TC"></typeparam>
            <param name="cqrMessage">secure encrypted msg </param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.Send_InitChatRoom_Soap``1(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Send_InitChatRoom_Soap{<typeparamref name="T"/>} Sends an chat roomm invitation
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:FullSrvMsg&lt;string&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.Send_InitChatRoom_SoapAsync``1(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Send_InitChatRoom_SoapAsync{<typeparamref name="T"/>} Sends async an chat roomm invitation
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:Task&lt;FullSrvMsg&lt;string&gt;&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.SendChatMsg_Soap``2(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``1},System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            SendChatMsg_Soap{<typeparamref name="T"/>, <typeparamref name="TC"/>} 
            </summary>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="fullClientMsg">client encrypted messagem, that server can't decrypt, <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/></param>fullClientMsgfullClientMsg
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:FullSrvMsg&lt;string&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.SendChatMsg_SoapAsync``2(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``1},System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            SendChatMsg_SoapAsync{<typeparamref name="T"/>, <typeparamref name="TC"/>} 
            </summary>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="fullClientMsg">client encrypted messagem, that server can't decrypt, <see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/></param>fullClientMsgfullClientMsg
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:Task&lt;FullSrvMsg&lt;string&gt;?&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.SendChatMsg_Soap_Simple``1(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},System.String,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            SendChatMsg_Soap_Simple{<typeparamref name="TS"/>} send a simple push message to the server
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="encryptedClientMsg">already encrypted client msg, that server can't read</param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:FullSrvMsg&lt;string&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.SendChatMsg_Soap_SimpleAsync``1(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},System.String,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            SendChatMsg_Soap_Simple{<typeparamref name="TS"/>} send a simple push message to the server
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="encryptedClientMsg">already encrypted client msg, that server can't read</param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:Task&lt;FullSrvMsg&lt;string&gt;&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.ReceiveChatMsg_Soap``1(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            ReceiveChatMsg_Soap{<typeparamref name="T"/>} is a polling chat server request
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:FullSrvMsg&lt;string&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.ReceiveChatMsg_SoapAsync``1(Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg{``0},System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            ReceiveChatMsg_SoapAsync{<typeparamref name="T"/>} async polling chat server request
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fullServerMsg"><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.FullSrvMsg`1"/>, containing char room number, sender and recipients</param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns><see cref="!:Task&lt;FullSrvMsg&lt;string&gt;&gt;"/>, containing char room number, last polled date, updated sender and recipients</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg.Send_CqrSrvMsg(System.String,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Send_CqrSrvMsg obsolete, please use <see cref="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.SendFirstSrvMsg_Soap(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)"/> instead
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1">
            <summary>
            Provides a secure encrypted message to send to the server or receive from server
            </summary>    
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.#ctor(System.String)">
            <summary>
            SrvMsg1 constructor with srvKey
            </summary>
            <param name="srvKey">server key (normally client ip + secret)</param>
            <exception cref="T:System.ArgumentNullException">thrown, when srvKey is null or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.CqrSrvMsg1(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            CqrSrvMsg1 encrypts a contact
            </summary>
            <param name="myContact">my contact in plain text string</param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns>encrypted msg via <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe"/></returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.NCqrSrvMsg1(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            NCqrSrvMsg1 decryptes an secure encrypted msg 
            </summary>
            <param name="cqrMessage">secure encrypted msg </param>
            <param name="encType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/></param>
            <returns><see cref="T:Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact"/>CqrContact decrypted string</returns>
            <exception cref="T:System.InvalidOperationException">will be thrown, 
            if server and client or both side use a different secret key 4 encryption</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.Test_Send1st_CqrSrvMsg1_Soap(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Test_Send1st_CqrSrvMsg1_Soap only test method, please use <see cref="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.SendFirstSrvMsg_Soap(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)"/>
            </summary>
            <param name="myContact"></param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.SendFirstSrvMsg_Soap(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            SendFirstSrvMsg_Soap, real soap method for 1st registration
            </summary>
            <param name="myContact"></param>
            <param name="srvIp"></param>
            <param name="encodingType"></param>
            <returns>my Contact with Guid Cuid</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.CqrXs.CqrSrv.SrvMsg1.Send1st_CqrSrvMsg1(Area23.At.Framework.Core.CqrXs.CqrMsg.CqrContact,System.Net.IPAddress,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)" -->
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.DH">
            <summary>
            Diffie Hellman key exchange
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.Rsa.GenerateNewRsaKeyPair">
            <summary>
            GenerateNewRsaKeyPair - generates a new rsa key pair
            </summary>
            <returns><see cref="!:AsymmetricCipherKeyPairy"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.Rsa.GetRsaKeyPair(System.String,System.String)">
            <summary>
            Get Rsa Key Pair by private and public key
            </summary>
            <param name="publicKey"></param>
            <param name="privateKey"></param>
            <returns><see cref="T:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.Rsa.Encrypt(System.Byte[])">
            <summary>
            Rsa Encrypt
            </summary>
            <param name="plainInBytes">plain input byte[]</param>
            <returns>encryptedOutBytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.Rsa.Decrypt(System.Byte[])">
            <summary>
            Rsa Decrypt
            </summary>
            <param name="encryptedInBytes">encrypted input byte array</param>
            <returns>plain out byte[]</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.Rsa.EncryptString(System.String)">
            <summary>
            Encrypts a string
            </summary>
            <param name="inPlainString">plain text string</param>
            <returns>Base64 encoded encrypted byte[]</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Asymmetric.Rsa.DecryptString(System.String)">
            <summary>
            Decrypts a string, that is truely a base64 encoded encrypted byte[]
            </summary>
            <param name="inCryptString">base64 encoded string from encrypted byte[]</param>
            <returns>plain text string (decrypted)</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum">
            <summary>
            CipherEnum maps BlockCipher algorithms <see cref="T:Org.BouncyCastle.Crypto.IBlockCipher"/>
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnumExtensions">
            <summary>
            Extensions methods for <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherEnumExtensions.GetCipherChar(Area23.At.Framework.Core.Crypt.Cipher.CipherEnum)">
            <summary>
            Extensions method for Enum <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>
            gets a character for each Cipher Algorithm, that is used here
            </summary>
            <param name="cipher">this <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/> extension</param>
            <returns>a <see cref="T:System.Char"/>, that is a short name for the encryption</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe">
            <summary>
            Provides a simple crypt pipe for <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.#ctor(Area23.At.Framework.Core.Crypt.Cipher.CipherEnum[])">
            <summary>
            CipherPipe constructor with an array of <see cref="!:CipherEnum[]"/> as inpipe
            </summary>
            <param name="cipherEnums">array of <see cref="!:CipherEnum[]"/> as inpipe</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.#ctor(System.String[])">
            <summary>
            CipherPipe constructor with an array of <see cref="!:string[]"/> cipherAlgos as inpipe
            </summary>
            <param name="cipherAlgos">array of <see cref="!:string[]"/> as inpipe</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.#ctor(System.Byte[],System.UInt32)">
            <summary>
            CipherPipe ctor with array of user key bytes
            </summary>
            <param name="keyBytes">user key bytes</param>
            <param name="maxpipe">maximum lentgh <see cref="F:Area23.At.Framework.Core.Static.Constants.MAX_PIPE_LEN"/></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.#ctor(System.String,System.String)">
            <summary>
            Constructs a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe"/> from key and hash
            by getting <see cref="!:byte[]">byte[] keybytes</see> with <see cref="M:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper.GetUserKeyBytes(System.String,System.String,System.Int32)"/>
            </summary>
            <param name="key">secret key to generate pipe</param>
            <param name="hash">hash value of secret key</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.EncryptBytesFast(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.CipherEnum,System.String,System.String)">
            <summary>
            Generic encrypt bytes to bytes
            </summary>
            <param name="inBytes">Array of byte</param>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/> both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="keyIv">key's iv</param>
            <returns>encrypted byte Array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.DecryptBytesFast(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.CipherEnum,System.String,System.String,System.Boolean)">
            <summary>
            Generic decrypt bytes to bytes
            </summary>
            <param name="cipherBytes">Encrypted array of byte</param>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="keyIv">key's iv</param>
            <returns>decrypted byte Array</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.MerryGoRoundEncrpyt(System.Byte[],System.String,System.String)" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CipherPipe.DecrpytRoundGoMerry(System.Byte[],System.String,System.String,System.Boolean)">
            <summary>
            DecrpytRoundGoMerry against clock turn -
            starts merry to turn arround from right to left against clock hour cycle 
            </summary>
            <param name="cipherBytes">encrypted byte array</param>
            <param name="secretKey">user secret key, normally email address</param>
            <param name="hashIv">hash relational to secret kay</param>
            <returns><see cref="!:byte[]"/> plain bytes</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Crypt.Cipher.Crypt" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Crypt.EncryptBytes(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.CipherEnum,System.String,System.String)">
            <summary>
            Generic encrypt bytes to bytes
            </summary>
            <param name="inBytes">Array of byte</param>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/> both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="keyIv">key's iv</param>
            <returns>encrypted byte Array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Crypt.DecryptBytes(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.CipherEnum,System.String,System.String)">
            <summary>
            Generic decrypt bytes to bytes
            </summary>
            <param name="cipherBytes">Encrypted array of byte</param>
            <param name="cipherAlgo">both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="keyIv">key's iv</param>
            <returns>decrypted byte Array</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper">
            <summary>
            static class CryptHelper provides static helper methods for encryption / decryption
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper.PrivateUserKey(System.String)">
            <summary>
            PrivateUserKey, helper to double private secret key to get a longer byte[]
            </summary>
            <param name="secretKey">users private secret key</param>
            <returns>doubled concatendated string of secretKey</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper.PrivateKeyWithUserHash(System.String,System.String)">
            <summary>
            PrivateKeyWithUserHash, helper to double private secret key with hash
            </summary>
            <param name="key">users private secret key</param>
            <param name="hash">users private secret key hash</param>
            <returns>doubled concatendated string of (secretKey + hash)</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper.KeyUserHashBytes(System.String,System.String,System.Boolean)" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper.GetUserKeyBytes(System.String,System.String,System.Int32)">
            <summary>
            GetUserKeyBytes gets symetric chiffer private byte[KeyLen] encryption / decryption key
            </summary>
            <param name="key">user key, default email address</param>
            <param name="hash">user hash</param>        
            <param name="keyLen">length of user key bytes, maximum length <see cref="F:Area23.At.Framework.Core.Static.Constants.MAX_KEY_LEN"/></param>
            <returns>Array of byte with length KeyLen</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.CryptParams">
            <summary>
            CryptParams parameters for encryption algorithm engine
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.#ctor">
            <summary>
            standard ctor with <see cref="F:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum.Aes"/> default
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.#ctor(Area23.At.Framework.Core.Crypt.Cipher.CipherEnum)">
            <summary>
            constructs a object with correct <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.Mode"/>, <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.BlockSize"/>, <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.KeyLen"/>
            for parameter <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.Cipher"/>
            </summary>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.#ctor(Area23.At.Framework.Core.Crypt.Cipher.CipherEnum,System.String,System.String)">
            <summary>
            constructs a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CryptParams"/> object by <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>
            with additional <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.Key"/> and <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.Hash"/>
            </summary>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/></param>
            <param name="key">secret key</param>
            <param name="hash">corresponding key hash</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.#ctor(Area23.At.Framework.Core.Crypt.Cipher.CryptParams)">
            <summary>
            Constructs instance via another object instance
            </summary>
            <param name="cryptParams">another instance</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.CryptParams.RequestAlgorithm(Area23.At.Framework.Core.Crypt.Cipher.CipherEnum)">
            <summary>
            static way to get valid <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CryptParams"/> for a requested <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>
            </summary>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/></param>
            <returns><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CryptParams"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes">
            <summary>
            <see cref="!:https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.aes?view=net-8.0" />
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes.#cctor">
            <summary>
            static constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes.AesGenWithKeyHash(System.String,System.String,System.Boolean)">
            <summary>
            AesGenWithKeyHash generates a new static Aes symetric encryption 
            </summary>
            <param name="secretKey">key param for encryption</param>
            <param name="userHostAddr">user host address is here part of private key</param>
            <param name="init">init three fish first time with a new key</param>
            <returns>true, if init was with same key successfull</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes.Encrypt(System.Byte[])">
            <summary>
            AES Encrypt by using RijndaelManaged
            </summary>
            <param name="plainData">Array of plain data byte</param>
            <returns>Array of encrypted data byte</returns>
            <exception cref="T:System.ArgumentNullException">is thrown when input enrypted <see cref="!:byte[]"/> is null or zero length</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes.Decrypt(System.Byte[])">
            <summary>
            AES Decrypt by using RijndaelManaged
            </summary>
            <param name="encryptedBytes">Array of encrypted data byte</param>
            <returns>Array of plain data byte</returns>
            <exception cref="T:System.ArgumentNullException">is thrown when input enrypted <see cref="!:byte[]"/> is null or zero length</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes.EncryptString(System.String)">
            <summary>
            Encrypts a string
            </summary>
            <param name="inPlainString">plain text string</param>
            <returns>Base64 encoded encrypted byte[]</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Aes.DecryptString(System.String)">
            <summary>
            Decrypts a string, that is truely a base64 encoded encrypted byte[]
            </summary>
            <param name="inCryptString">base64 encoded string from encrypted byte[]</param>
            <returns>plain text string (decrypted)</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle">
            <summary>
            Generic CryptBounceCastle Encryption / Decryption class
            supports <see cref="T:Org.BouncyCastle.Crypto.Engines.CamelliaEngine"/>, <see cref="T:Org.BouncyCastle.Crypto.Engines.Gost28147Engine"/>, <see cref="T:Org.BouncyCastle.Crypto.Engines.RC2Engine"/>,
            <see cref="T:Org.BouncyCastle.Crypto.Engines.RC532Engine"/>, <see cref="T:Org.BouncyCastle.Crypto.Engines.RC6Engine"/>, <see cref="T:Org.BouncyCastle.Crypto.Engines.RijndaelEngine">RijndaelEngine is standard AES</see>, 
            <see cref="T:Org.BouncyCastle.Crypto.Engines.SkipjackEngine"/>, <see cref="T:Org.BouncyCastle.Crypto.Engines.TeaEngine"/>, <see cref="T:Org.BouncyCastle.Crypto.Engines.TnepresEngine"/>,
            <see cref="T:Org.BouncyCastle.Crypto.Engines.XteaEngine"/>, ... and many more
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.Size">
            <summary>
            Block Size
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.KeyLen">
            <summary>
            KeyLen byte[KeyLen] of Key and Iv
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.CryptoBlockCipher">
            <summary>
            Base symmetric key block cipher interface, contains at runtime block cipher instance to constructor
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.CryptoBlockCipherPadding">
            <summary>
            IBlockCipherPadding BlockCipherPadding mode
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.Mode">
            <summary>
            Valid modes are currently "CBC", "ECB", "CFB", "CCM", "CTS", "EAX", "GOFB"
            <see cref="N:Org.BouncyCastle.Crypto.Modes"/> for crypto modes details.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.#ctor">
            <summary>
            parameterless default constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Generic CryptBounceCastle constructor
            </summary>
            <param name="blockCipher">Base symmetric key block cipher interface, pass instance to constructor, e.g. 
            <code>CryptBounceCastle cryptCastle = new CryptBounceCastle(new Org.BouncyCastle.Crypto.Engines.CamelliaEngine());</code></param>
            <param name="size">block size with default value 256</param>
            <param name="keyLen">key length with default value 32</param>
            <param name="mode">cipher mode string, default value "ECB"</param>
            <param name="userHostAddr">user host address</param>
            <param name="secretKey">key param for encryption</param>
            <param name="init">init <see cref="!:ThreeFish"/> first time with a new key</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.#ctor(Area23.At.Framework.Core.Crypt.Cipher.CryptParams,System.Boolean)">
            <summary>
            Generic CryptBounceCastle constructor
            </summary>
            <param name="cparams">parameters to crypt</param>
            <param name="init">init <see cref="!:ThreeFish"/> first time with a new key</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.GetUserKeyBytes(System.String,System.String)">
            <summary>
            GetUserKeyBytes gets symetric chiffer private byte[KeyLen] encryption / decryption key
            </summary>
            <param name="secretKey">user secret key, default email address</param>
            <param name="secretHash">user host ip address</param>
            <returns>Array of byte with length KeyLen</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.Encrypt(System.Byte[])">
            <summary>
            Generic CryptBounceCastle Encrypt member function
            difference between out parameter encryptedData and return value, are 2 different encryption methods, but with the same result at the end
            </summary>
            <param name="plainData">plain data as <see cref="!:byte[]"/></param>
            <returns>encrypted data <see cref="!:byte[]">bytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.Decrypt(System.Byte[])">
            <summary>
            Generic CryptBounceCastle Decrypt member function
            difference between out parameter decryptedData and return value, are 2 different decryption methods, but with the same result at the end
            </summary>
            <param name="cipherData">encrypted <see cref="!:byte[]">bytes</see></param>
            <returns>decrypted plain byte[] data</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.EncryptString(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Generic CryptBounceCastle Encrypt String method
            </summary>
            <param name="inString">plain string to encrypt</param>
            <param name="encodingType">
            beware of using <see cref="F:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType.Uu"/>; 
            default <see cref="F:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType.Base64"/>
            </param>
            <returns>encoded encrypted string, default base64 encoded</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptBounceCastle.DecryptString(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            Generic CryptBounceCastle Decrypt String method
            </summary>
            <param name="inCryptString">encoded encrypted string, default base64 encoded</param>
            <param name="encodingType">
            beware of using <see cref="F:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType.Uu"/>; 
            default <see cref="F:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType.Base64"/>
            </param>
            <returns>plain text decrypted string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered">
            <summary>
            CryptParamsPrefered prefered params for symmetric block cipher
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered.#ctor">
            <summary>
            standard ctor with <see cref="F:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum.Aes"/> default
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered.#ctor(Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.Boolean)">
            <summary>
            constructs a object with correct <see cref="T:Org.BouncyCastle.Crypto.Engines.SM2Engine.Mode"/>, <see cref="T:System.Drawing.Size"/>, <see cref="!:KeyLen"/>
            for parameter <see cref="N:Area23.At.Framework.Core.Crypt.Cipher"/>
            </summary>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered.#ctor(Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.String,System.String,System.Boolean)">
            <summary>
            constructs a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered"/> object 
            with correct <see cref="T:Org.BouncyCastle.Crypto.Engines.SM2Engine.Mode"/>, <see cref="T:System.Drawing.Size"/>, <see cref="!:KeyLen"/>
            with additional <see cref="!:Key"/> and <see cref="N:Area23.At.Framework.Core.Crypt.Hash"/>
            for parameter <see cref="N:Area23.At.Framework.Core.Crypt.Cipher"/>
            </summary>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered.RequestPreferedAlgorithm(Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.Boolean)">
            <summary>
            static way to get valid <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered"/> for a requested <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/>
            </summary>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/></param>
            <returns><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.CryptParamsPrefered"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3">
            <summary>
            static Des3 encryption helper
            <see cref="!:https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.tripledes.-ctor?view=net-8.0" />
            <seealso cref="!:https://www.c-sharpcorner.com/article/tripledes-encryption-and-decryption-in-c-sharp/"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3.#cctor">
            <summary>
            static constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3.Des3GenWithKeyHash(System.String,System.String,System.Boolean)">
            <summary>
            Des3GenWithKeyHash generates 3Des Enginge with key and hash
            </summary>
            <param name="secretKey">your plain text secret key</param>
            <param name="userHash">user key hash</param>
            <param name="init">init TripleDes first time with a new key</param>
            <returns>true, if init was with same key successfull</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3.Encrypt(System.Byte[])">
            <summary>
            3Des encrypt bytes
            </summary>
            <param name="inBytes">Hex bytes</param>
            <returns>byte[] encrypted bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3.Decrypt(System.Byte[])">
            <summary>
            3Des decrypt bytes
            </summary>
            <param name="inBytes">Hex bytes encrypted</param>
            <returns>byte[] decrypted bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3.EncryptString(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            3Des encrypt string
            </summary>
            <param name="inString">string in plain text</param>
            <returns>Base64 encoded encrypted byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Des3.DecryptString(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            3Des decrypts string
            </summary>
            <param name="cipherText">Base64 encoded encrypted byte[]</param>
            <returns>plain text string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.FishRequiresAesEngineException">
            <summary>
            this exception is only implemented, because of a 1st 
            where 3-fish rides on AesEngine
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564.#cctor">
            <summary>
            static RC564 constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564.RC564GenWithKey(System.String,System.String,System.Boolean)">
            <summary>
            RC564GenWithKey - Generates a new <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564"/> with secret key
            </summary>
            <param name="secretKey">key param for encryption</param>
            <param name="usrHash">user key hash</param>
            <param name="init">init <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564"/> first time with a new key</param>
            <returns>true, if init was with same key successfull</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564.Encrypt(System.Byte[])">
            <summary>
            RC564 Encrypt with <see cref="T:Org.BouncyCastle.Crypto.Engines.RC564Engine"/>
            </summary>
            <param name="plainData">plain data as <see cref="!:byte[]"/></param>
            <returns>encrypted data <see cref="!:byte[]">bytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564.Decrypt(System.Byte[])">
            <summary>
            RC564 Decrypt with <see cref="T:Org.BouncyCastle.Crypto.Engines.RC564Engine"/>
            </summary>
            <param name="cipherData">encrypted <see cref="!:byte[]">bytes</see></param>
            <returns>decrypted plain byte[] data</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564.EncryptString(System.String)">
            <summary>
            RC564 Encrypt String method
            </summary>
            <param name="inString">plain string to encrypt</param>
            <returns>base64 encoded encrypted string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.RC564.DecryptString(System.String)">
            <summary>
            RC564 Decrypt String method
            </summary>
            <param name="inCryptString">base64 encrypted string</param>
            <returns>plain text decrypted string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent">
            <summary>
            Serpent static class implementing Serpent symetric chiffer algorithm
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent.#cctor">
            <summary>
            static constructor for serpent encryption
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent.SerpentGenWithKey(System.String,System.String,System.Boolean)">
            <summary>
            SerpentGenWithKey => Generates new <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent"/> with secret key
            </summary>
            <param name="secretKey">key param for encryption</param>
            <param name="usrHash">user key hash</param>
            <param name="init">init <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent"/> first time with a new key</param>
            <returns>true, if init was with same key successfull</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent.Encrypt(System.Byte[])">
            <summary>
            Serpent Encrypt member function
            </summary>
            <param name="plainData">plain data as <see cref="!:byte[]"/></param>
            <returns>encrypted data <see cref="!:byte[]">bytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent.Decrypt(System.Byte[])">
            <summary>
            Serpent Decrypt member function
            </summary>
            <param name="cipherData">encrypted <see cref="!:byte[]">bytes</see></param>
            <returns>decrypted plain byte[] data</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent.EncryptString(System.String)">
            <summary>
            Serpent Encrypt String method
            </summary>
            <param name="inString">plain string to encrypt</param>
            <returns>base64 encoded encrypted string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.Serpent.DecryptString(System.String)">
            <summary>
            Serpent Decrypt String method
            </summary>
            <param name="inCryptString">base64 encrypted string</param>
            <returns>plain text decrypted string</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum" -->
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnumExtensions">
            <summary>
            SymmCipherEnumExtensions provides extension methods for <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnumExtensions.GetSymmCipherTypes">
            <summary>
            GetSymmCipherTypes 
            </summary>
            <returns>an array of all SymmCipherEnum values</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnumExtensions.GetCharSymmCipherDict">
            <summary>
            GetCharSymmCipherDict gets <see cref="!:Dictionary&lt;char, SymmCipherEnum&gt;"/>,
            where hexbyte as char is mapped to <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum" />
            </summary>
            <returns><see cref="!:Dictionary&lt;char, SymmCipherEnum&gt;"/></returns>        
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnumExtensions.GetByteSymmCipherDict">
            <summary>
            GetByteSymmCipherDict gets <see cref="!:Dictionary&lt;byte, SymmCipherEnum&gt;"/>,
            where hex byte value is mapped to  <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum" />
            </summary>
            <returns><see cref="!:Dictionary&lt;byte, SymmCipherEnum&gt;"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnumExtensions.GetSymmCipherChar(Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum)">
            <summary>
            Extensions method for Enum <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/>
            gets a character for each Cipher Algorithm, that is used here
            </summary>
            <param name="symmCipher">this <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/></param>
            <returns>a <see cref="T:System.Char"/>, that is a short name for the encryption</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnumExtensions.ToCipherEnum(Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum)">
            <summary>
            ExtensionMethod ToCipherEnum converts <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/> to <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/>
            </summary>
            <param name="symmCipher"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/> to convert</param>
            <returns></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe">
            <summary>
            Provides a simple crypt pipe for <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.#ctor(Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum[])">
            <summary>
            SymmCipherPipe constructor with an array of <see cref="!:SymmCipherEnum[]"/> as inpipe
            </summary>
            <param name="symmCipherEnums">array of <see cref="!:SymmCipherEnum[]"/> as inpipe</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.#ctor(System.String[])">
            <summary>
            SymmCipherPipe constructor with an array of <see cref="!:string[]"/> as inpipe
            </summary>
            <param name="symmCipherAlgos">array of <see cref="!:string[]"/> as inpipe</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.#ctor(System.Byte[],System.UInt32)">
            <summary>
            SymmCipherPipe ctor with array of user key bytes
            </summary>
            <param name="keyBytes">user key bytes</param>
            <param name="maxpipe">maximum lentgh <see cref="F:Area23.At.Framework.Core.Static.Constants.MAX_PIPE_LEN"/></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.#ctor(System.String,System.String)">
            <summary>
            Constructs a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe"/> from key and hash
            by getting <see cref="!:byte[]">byte[] keybytes</see> with <see cref="M:Area23.At.Framework.Core.Crypt.Cipher.CryptHelper.GetUserKeyBytes(System.String,System.String,System.Int32)"/>
            </summary>
            <param name="key">secret key to generate pipe</param>
            <param name="hash">hash value of secret key</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.EncryptBytesFast(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.String,System.String)">
            <summary>
            Generic encrypt bytes to bytes
            </summary>
            <param name="inBytes">Array of byte</param>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/> both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="keyIv">key's iv</param>
            <returns>encrypted byte Array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.DecryptBytesFast(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.String,System.String,System.Boolean)">
            <summary>
            Generic decrypt bytes to bytes
            </summary>
            <param name="cipherBytes">Encrypted array of byte</param>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum"/>both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="keyIv">key's iv</param>
            <returns>decrypted byte Array</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.MerryGoRoundEncrpyt(System.Byte[],System.String,System.String)" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherPipe.DecrpytRoundGoMerry(System.Byte[],System.String,System.String,System.Boolean)">
            <summary>
            DecrpytRoundGoMerry against clock turn -
            starts merry to turn arround from right to left against clock hour cycle 
            </summary>
            <param name="cipherBytes">encrypted byte array</param>
            <param name="secretKey">user secret key, normally email address</param>
            <param name="hashIv">hash relational to secret kay</param>
            <returns><see cref="!:byte[]"/> plain bytes</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCrypt">
            <summary>
            Basic class for symmetric cipher encryption
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCrypt.EncryptBytes(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.String,System.String)">
            <summary>
            Generic encrypt bytes to bytes
            </summary>
            <param name="inBytes">Array of byte</param>
            <param name="cipherAlgo"><see cref="T:Area23.At.Framework.Core.Crypt.Cipher.CipherEnum"/> both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="hashIv">key hash iv</param>
            <returns>encrypted byte Array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCrypt.DecryptBytes(System.Byte[],Area23.At.Framework.Core.Crypt.Cipher.Symmetric.SymmCipherEnum,System.String,System.String)">
            <summary>
            Generic decrypt bytes to bytes
            </summary>
            <param name="cipherBytes">Encrypted array of byte</param>
            <param name="cipherAlgo">both symmetric and asymetric cipher algorithms</param>
            <param name="secretKey">secret key to decrypt</param>
            <param name="hashIv">key hash iv</param>
            <returns>decrypted byte Array</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix">
            <summary>
            Simple sbyte reduced to 0x0 .. 0xf symmetric cipher mapping matrix,
            maybe already invented, but created by zen@area23.at (Heinrich Elsigan)
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.MatrixPermutationBase">
            <summary>
            MatrixPermutationBase is a Permutation Matrix where every value will mapped to itself
            ( 
                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.MagicOrder" -->
        <!-- Badly formed XML comment ignored for member "P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.MatrixPermutationKey" -->
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.InverseMatrix">
            <summary>
            Inverse Matrix 
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.PermutationKeyHash">
            <summary>
            PermutationKeyHash is same as <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.MatrixPermutationKey"/>
            Advantage of <see cref="!:HashSet&lt;sbyte&gt;"/> is, that no duplicated values can be inside
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Processes one BLOCK with BLOCK_SIZE <see cref="F:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.BLOCK_SIZE"/>
            </summary>
            <param name="inBuf"></param>
            <param name="inOff"></param>
            <param name="outBuf"></param>
            <param name="outOff"></param>
            <returns></returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.#ctor">
            <summary>
            public constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            initializes a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix"/> with secret user key string and hash iv
            </summary>
            <param name="secretKey">user's secret key</param>
            <param name="hashIV">private key hash iv string</param>
            <param name="fullSymmetric">
            fullSymmetric means that zen matrix is it's inverse element 
            and decrypts back to plain text, when encrypting twice or ²</param>       
            <exception cref="T:System.ApplicationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.#ctor(System.Byte[],System.Boolean)">
            <summary>
            initializes a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix"/> with an array of key bytes
            </summary>
            <param name="keyBytes">array of key bytes</param>
            <param name="fullSymmetric">
            fullSymmetric means that zen matrix is it's inverse element 
            and decrypts back to plain text, when encrypting twice or ²</param> 
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.InitMatrixSymChiffer">
            <summary>
            InitMatrixSymChiffer - base initialization of variables, needed for matrix sym chiffer encryption
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.ZenMatrixGenWithBytes(System.Byte[],System.Boolean)">
            <summary>
            Generates ZenMatrix with key bytes
            </summary>
            <param name="keyBytes">must have at least 4 bytes and will be truncated after 16 bytes
            only the first 16 bytes will be taken from keyBytes for <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix"/>
            </param>
            <returns>true, if init was with same key successfull</returns>
            <param name="fullSymmetric">
            fullSymmetric means that zen matrix is it's inverse element 
            and decrypts back to plain text, when encrypting twice or ²</param>       
            <exception cref="T:System.ApplicationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.ProcessEncryptBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            ProcessEncryptBytes, processes the next len=16 bytes to encrypt, starting at offSet
            </summary>
            <param name="inBytes">in bytes array to encrypt</param>
            <param name="offSet">starting offSet</param>
            <param name="len">len of byte block (default 16)</param>
            <returns>byte[len] (default: 16) segment of encrypted bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.ProcessDecryptBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            ProcessDecryptBytes  processes the next len=16 bytes to decrypt, starting at offSet
            </summary>
            <param name="inBytesEncrypted">encrypted bytes array to deccrypt</param>
            <param name="offSet">starting offSet</param>
            <param name="len">len of byte block (default 16)</param>
            <returns>byte[len] (default: 16) segment of decrypted bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.Encrypt(System.Byte[])">
            <summary>
            MatrixSymChiffer Encrypt member function
            </summary>
            <param name="pdata">plain data as <see cref="!:byte[]"/></param>
            <returns>encrypted data <see cref="!:byte[]">bytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.Decrypt(System.Byte[])">
            <summary>
            MatrixSymChiffer Decrypt member function
            </summary>
            <param name="cdata">encrypted cipher <see cref="!:byte[]">bytes</see></param>
            <returns>decrypted plain byte[] data</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.EncryptTextToBytes(System.String)">
            <summary>
            Encrypts a string
            </summary>
            <param name="inPlainString">plain text string</param>
            <returns>Base64 encoded encrypted byte[]</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.EncryptTextToEncoded(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)" -->
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.EncryptBytesToEncoded(System.Byte[],Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.DecryptTextFromBytes(System.Byte[])">
            <summary>
            Decrypts a string, that is truely a base64 encoded encrypted byte[]
            </summary>
            <param name="inCryptString">base64 encoded string from encrypted byte[]</param>
            <returns>plain text string (decrypted)</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.DecryptTextFromEncoded(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)" -->
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.DecryptBytesFromEncoded(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)" -->
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.BuildInverseMatrix(System.SByte[],System.Int32)">
            <summary>
            BuildInverseMatrix, builds the determinant decryption matrix for sbyte[16] encryption matrix
            </summary>
            <param name="matrix">sbyte[16] encryption matrix</param>
            <returns><see cref="!:sbyte[]">sbyte[16]</see> decryption matrix (determinante)</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix.MapByteValue(System.Byte@,System.Byte@,System.Boolean)" -->
        <member name="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2">
            <summary>
            More complex sbyte mapping from 0x0 .. to 0xf as symmetric cipher matrix
            position swaps and byte mappings are seperated in 2 matrizes 
            and maybe I will add ZenMatrix3 l8r, to multiply and divide byte values with a 3rd matrix 
            for mapping sbyte[1] => byte[1] 0xf => 0xab and generate 
            
            maybe this encryption is already invented, but created at Git by zen@area23.at (Heinrich Elsigan)
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.MatrixPermutationKey2">
            <summary>
            abstraction of a 0x10 => 0x10 matrix, for example
            <see cref="!:MatrixPermutationKey"/> 
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.InverseMatrix2">
            <summary>
            Inverse Matrix 2 
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.PermutationKeyHash2">
            <summary>
            PermutationKeyHash is same as <see cref="P:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.MatrixPermutationKey2"/>
            Advantage of <see cref="!:HashSet&lt;sbyte&gt;"/> is, that no duplicated values can be inside
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.#ctor">
            <summary>
            public constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            initializes a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix"/> with secret user key string and hash iv
            </summary>
            <param name="secretKey">user's secret key</param>
            <param name="hashIV">private key hash iv string</param>
            <param name="fullSymmetric">
            fullSymmetric means that zen matrix is it's inverse element 
            and decrypts back to plain text, when encrypting twice or ²</param>       
            <exception cref="T:System.ApplicationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.#ctor(System.Byte[],System.Boolean)">
            <summary>
            initializes a <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix"/> with an array of key bytes
            </summary>
            <param name="keyBytes">array of key bytes</param>
            <param name="fullSymmetric">
            fullSymmetric means that zen matrix is it's inverse element 
            and decrypts back to plain text, when encrypting twice or ²</param> 
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.InitMatrixSymChiffer2">
            <summary>
            InitMatrixSymChiffer - base initialization of variables, needed for matrix sym chiffer encryption
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.ZenMatrixGenWithBytes2(System.Byte[],System.Boolean)">
            <summary>
            Generates ZenMatrix with key bytes
            </summary>
            <param name="keyBytes">must have at least 4 bytes and will be truncated after 16 bytes
            only the first 16 bytes will be taken from keyBytes for <see cref="T:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix"/>
            </param>
            <returns>true, if init was with same key successfull</returns>
            <param name="fullSymmetric">
            fullSymmetric means that zen matrix is it's inverse element 
            and decrypts back to plain text, when encrypting twice or ²</param>       
            <exception cref="T:System.ApplicationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.ProcessEncryptBytes2(System.Byte[],System.Int32,System.Int32)">
            <summary>
            ProcessEncryptBytes2, processes the next len=16 bytes to encrypt, starting at offSet
            </summary>
            <param name="inBytesPadding">in bytes array to encrypt</param>
            <param name="offSet">starting offSet</param>
            <param name="len">len of byte block (default 16)</param>
            <returns>byte[len] (default: 16) segment of encrypted bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.ProcessDecryptBytes2(System.Byte[],System.Int32,System.Int32)">
            <summary>
            ProcessDecryptBytes  processes the next len=16 bytes to decrypt, starting at offSet
            </summary>
            <param name="inBytesEncrypted">encrypted bytes array to deccrypt</param>
            <param name="offSet">starting offSet</param>
            <param name="len">len of byte block (default 16)</param>
            <returns>byte[len] (default: 16) segment of decrypted bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.Encrypt(System.Byte[])">
            <summary>
            MatrixSymChiffer Encrypt member function
            </summary>
            <param name="pdata">plain data as <see cref="!:byte[]"/></param>
            <returns>encrypted data <see cref="!:byte[]">bytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.Decrypt(System.Byte[])">
            <summary>
            MatrixSymChiffer Decrypt member function
            </summary>
            <param name="cdata">encrypted cipher <see cref="!:byte[]">bytes</see></param>
            <returns>decrypted plain byte[] data</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.BuildInverseMatrix2(System.SByte[],System.Int32)">
            <summary>
            BuildInverseMatrix, builds the determinant decryption matrix for sbyte[16] encryption matrix
            </summary>
            <param name="matrix">sbyte[16] encryption matrix</param>
            <returns><see cref="!:sbyte[]">sbyte[16]</see> decryption matrix (determinante)</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Cipher.Symmetric.ZenMatrix2.MapByteValue2(System.Byte@,System.Byte@,System.Boolean)" -->
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Base16">
            <summary>
            RawString hexadecimal byte encoding / decoding
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base16.Encode(System.Byte[])">
            <summary>
            Encodes a byte[] 
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>hex16 encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base16.Decode(System.String)">
            <summary>
            Decodes a hex string to byte[]
            </summary>
            <param name="hexString">hex16 encoded string</param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base16.ToBase16(System.Byte[])">
            <summary>
            ToBase16 converts a binary byte array to hex string
            </summary>
            <param name="inBytes">byte array</param>
            <returns>hex string</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base16.FromBase16(System.String)">
            <summary>
            FromBase16 transforms a hex string to binary byte array
            </summary>
            <param name="hexStr">a hex string</param>
            <returns>binary byte array</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32">
            <summary>
            Base32 encoding is a mapping for double hex from A-Z0-7 (32 chiffers per digit)
            <see href="https://gist.github.com/erdomke/9335c394c5cc65404c4cf9aceab04143"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32.Encode(System.Byte[])">
            <summary>
            Encodes byte[] to valid encode formatted string
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32.Decode(System.String)">
            <summary>
            Decodes an encoded string to byte[]
            </summary>
            <param name="encodedString">encoded string</param>
            <returns>byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32.IsValid(System.String)">
            <summary>
            Checks if a string is a valid encoded string
            </summary>
            <param name="encodedString">encoded string</param>
            <returns>true, when encoding is OK, otherwise false, if encoding contains illegal characters</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32.FromBase32(System.String)">
            <summary>
            FromBase32 converts a base32 string to a binary byte array
            </summary>
            <param name="encoded">base32 encoded string</param>
            <returns>byte array</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32.ToBase32(System.Byte[],System.Boolean)">
            <summary>
            ToBase32
            </summary>
            <param name="data">binary data in byte array to convert</param>
            <param name="padOutput">block padding with =</param>
            <returns>Base32 encoded string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Base64">
            <summary>
            Base64 mime standard encoding
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base64.Encode(System.Byte[])">
            <summary>
            Encodes byte[] to valid encode formatted string
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Base64.Decode(System.String)">
            <summary>
            Decodes an encoded string to byte[]
            </summary>
            <param name="encodedString">encoded string</param>
            <returns>byte array</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper" -->
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.KeyToHex(System.String)">
            <summary>
            KeyHexString transforms a private secret key to hex string
            </summary>
            <param name="key">private secret key</param>
            <returns>hex string of bytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.EncodeBytes(System.Byte[],Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType,System.Boolean,System.Boolean)">
            <summary>
            EncodeBytes encodes byte[] inBytes by encodingMethod to an encoded text string
            </summary>
            <param name="inBytes">inBytes to encdode</param>
            <param name="encodingType">EncodingTypes are "None", "Hex16", "Base16", "Base32", "Hex32", "Uu", "Base64".
            "Base64" is default.</param>
            <param name="fromPlain">Only for uu: true, if <see cref="!:encryptBytes"/> represent a binary without encryption</param>
            <param name="fromFile">Only for uu: true, if file and not textbox will be encrypted, default (false)</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.EncodeBytesToString(System.Byte[],System.String)">
            <summary>
            EncodeBytes encodes byte[] inBytes by encodingMethod as plain text param enCodingString to an encoded text string
            </summary>
            <param name="inBytes">inBytes to encdode</param>
            <param name="enCodingString">ebcoding enum <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/> as plain string
            "Base64" is default.</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.DecodeText(System.String,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType,System.Boolean,System.Boolean)">
            <summary>
            EncodedTextToBytes transforms an encoded text string into a <see cref="!:byte[]">býte array</see>
            </summary>
            <param name="cipherText">encoded (encrypted) text string</param>
            <param name="encodingType"><see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/> could be 
            "None", "Hex16", "Base16", "Base32", "Hex32", "Uu", "Base64". "Base64" is default.</param>
            <param name="fromPlain">Only for uu: true, if <see cref="!:encryptBytes"/> represent a binary without encryption</param>
            <param name="fromFile">Only for uu: true, if file and not textbox will be encrypted, default (false)</param>
            <returns>binary byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.DecodeText(System.String,System.String)">
            <summary>
            DecodeText decodes an encoded text string to a <see cref="!:byte[]">býte array</see>
            </summary>
            <param name="inText">encoded (encrypted) text string</param>
            <param name="enCodingString">ebcoding enum <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/> as plain string
            "Base64" is default.</param>
            <returns>binary byte array</returns>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.DecodeBytes(System.Byte[],System.String)">
            <summary>
            DecodeText decodes an encoded text string to a <see cref="!:byte[]">býte array</see>
            </summary>
            <param name="inText">encoded (encrypted) text string</param>
            <param name="enCodingString">ebcoding enum <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType"/> as plain string
            "Base64" is default.</param>
            <returns>binary byte array</returns>>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.GetBytesFromString(System.String,System.Int32,System.Boolean)">
            <summary>
            GetBytesFromString gets byte[] array representing binary transformation of a string
            </summary>
            <param name="inString">string to transfer to binary byte[] data</param>
            <param name="blockSize">current block size, default: 256</param>
            <param name="upStretchToCorrectBlockSize">fills at the end of byte[] padding zero 0 bytes, default: false</param>
            <returns>byte[] array of binary byte</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.GetStringFromBytesTrimNulls(System.Byte[])">
            <summary>
            GetStringFromBytesTrimNulls gets a plain text string from binary byte[] data and truncate all 0 byte at the end.
            </summary>
            <param name="decryptedBytes">decrypted byte[]</param>
            <returns>truncated string without a lot of \0 (null) characters</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.GetBytesTrimNulls(System.Byte[])">
            <summary>
            GetBytesTrimNulls gets a byte[] from binary byte[] data and truncate all 0 byte at the end.
            </summary>
            <param name="inBytes">decrypted byte[]</param>
            <returns>truncated byte[] without a lot of \0 (null) characters</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.GetBytesTrimCrLfNulls(System.Byte[])">
            <summary>
            GetBytesTrimNulls gets a byte[] from binary byte[] data and truncate all 0 byte at the end.
            </summary>
            <param name="inBytes">decrypted byte[]</param>
            <returns>truncated byte[] without a lot of \0 (null) characters</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.EnDeCodeHelper.Trim_Decrypted_Text(System.String)">
            <summary>
            Trim_Decrypted_Text removes all special control characters from a text string
            </summary>
            <param name="decryptedText">string to trim and strip from special control characters.</param>
            <returns>text only string with at least text formation special characters.</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex16">
            <summary>
            Normal hexadecimal byte encoding / decoding
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex16.Encode(System.Byte[])">
            <summary>
            Encodes byte[] to valid encode formatted string
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex16.Decode(System.String)">
            <summary>
            Decodes an encoded string to byte[]
            </summary>
            <param name="encodedString">encoded string</param>
            <returns>byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex16.ToHex16(System.Byte[])">
            <summary>
            Encode ToHex converts a binary byte array to hex string
            </summary>
            <param name="inBytes">byte array</param>
            <returns>hex string</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex16.FromHex16(System.String)">
            <summary>
            Decode FromHex transforms a hex string to binary byte array
            </summary>
            <param name="hexStr">a hex string</param>
            <returns>binary byte array</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex32">
            <summary>
            Hex32 encoding is a mapping for double hex from 0-9A-V (32 chiffers per digit), padding char is =
            <see href="https://datatracker.ietf.org/doc/html/rfc4648#section-7" />
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex32.Encode(System.Byte[])">
            <summary>
            Encodes byte[] to valid encode formatted string
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex32.Decode(System.String)">
            <summary>
            Decodes an encoded string to byte[]
            </summary>
            <param name="encodedString">encoded string</param>
            <returns>byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex32.FromHex32(System.String)">
            <summary>
            FromHex32 converts a base32 string to a binary byte array
            </summary>
            <param name="encoded">base32 encoded string</param>
            <returns>byte array</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex32.ToHex32(System.Byte[],System.Boolean)">
            <summary>
            ToHex32
            </summary>
            <param name="data">binary data in byte array to convert</param>
            <param name="padOutput">block padding with =</param>
            <returns>Base32 encoded string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.IDecodable">
            <summary>
            IDecodable is an common interface for <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Base16"/>, <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Base32"/>, <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Base64"/>,
            <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex16"/>, <see cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Hex32"/> and <seealso cref="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu"/> Encoding / Decoding
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.RawString">
            <summary>
            Base16 hexadecimal byte encoding / decoding
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.RawString.Encode(System.Byte[])">
            <summary>
            Encodes a byte[] 
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>hex16 encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.RawString.Decode(System.String)">
            <summary>
            Decodes a hex string to byte[]
            </summary>
            <param name="hexString">hex16 encoded string</param>
            <returns></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu">
            <summary>
            Uu is unix2unix uuencode uudecode
            Thanks to https://github.com/n3wt0n/Crypto/blob/master/DBTek.Crypto.Shared/UUEncoder.cs
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.Encode(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Encodes byte[] to valid encode formatted string
            </summary>
            <param name="inBytes">byte array to encode</param>
            <returns>encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.Decode(System.String,System.Boolean,System.Boolean)">
            <summary>
            Decodes an encoded string to byte[]
            </summary>
            <param name="encodedString">encoded string</param>
            <returns>byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.ToUu(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            ToUu
            </summary>
            <param name="inBytes">binary byte array</param>
            <param name="originalUue">true, if only uuencode without encrpytion</param>
            <param name="fromFile">Only for uu: true, if file and not textbox will be encrypted, default (false)</param>
            <returns>uuencoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.FromUu(System.String,System.Boolean,System.Boolean)">
            <summary>
            FromUu
            </summary>
            <param name="uuEncStr">uuencoded string</param>
            <param name="originalUue">Only for uu: true, if <see cref="!:uuEncStr"/> represent a binary without encryption</param>
            <param name="fromFile">Only for uu: true, if file and not textbox will be encrypted, default (false)</param>
            <returns>binary byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.UuEncode(System.String)">
            <summary>
            UuEncode unix 2 unix encodes a string
            </summary>
            <param name="plainText">plain text string to encode</param>
            <returns>uuencoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.UuDecode(System.String)">
            <summary>
            UuDecode unix 2 unix decodes a string
            </summary>
            <param name="uuEncodedStr">uuencoded string</param>
            <returns>uudecoded plain text</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.UuEncodeString(System.String)">
            <summary>
            Encode a string using UUEncoder, thanks to
            Thanks to https://github.com/n3wt0n/Crypto/blob/master/DBTek.Crypto.Shared/UUEncoder.cs
            </summary>
            <param name="srcString">The source string to encode</param>
            <returns>The encoded string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.EnDeCoding.Uu.UuDecodeString(System.String)">
            <summary>
            Decode a string encoded with UUEncoder
            Thanks to https://github.com/n3wt0n/Crypto/blob/master/DBTek.Crypto.Shared/UUEncoder.cs
            </summary>
            <param name="srcString">The encoded string to decode</param>
            <returns>The decoded string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Hash.MD5Sum">
            <summary>
            MD5Sum hashes a md5 sum for a string, stream, byte[], 
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Hash.MD5Sum.Hash(System.String,System.Boolean)">
            <summary>
            Hash
            </summary>
            <param name="filePath">filePath to file</param>
            <param name="showFileName">show fileName after hash sum</param>
            <returns></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Hash.Sha256Sum">
            <summary>
            Sha256Sum creates Sha256Sum of a file or stream or byte[] or string
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Hash.Sha256Sum.Hash(System.String,System.Boolean)">
            <summary>
            Hashes a file
            </summary>
            <param name="filePath">full(unc) path to file</param>
            <param name="fileName">optional filename to add after hash</param>
            <returns>Sha512 hash of file with optional fileName at end</returns>
            <exception cref="T:System.ArgumentNullException">thrown, when filePath == null | filePath == "" | !File.Exists(filePath)</exception>        
        </member>
        <member name="T:Area23.At.Framework.Core.Crypt.Hash.Sha512Sum">
            <summary>
            Sha256Sum creates Sha512Sum of a file or stream or byte[] or string
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Hash.Sha512Sum.Hash(System.String,System.Boolean)">
            <summary>
            Hashes a file
            </summary>
            <param name="filePath">full(unc) path to file</param>
            <param name="fileName">optional filename to add after hash</param>
            <returns>Sha512 hash of file with optional fileName at end</returns>
            <exception cref="T:System.ArgumentNullException">thrown, when filePath == null | filePath == "" | !File.Exists(filePath)</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Hash.Sha512Sum.Hash(System.String,System.String)">
            <summary>
            Hashes a string strng
            </summary>
            <param name="strng"><see cref="T:System.String">string strng</see></param>
            <param name="fileName">optional filename to add after hash</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Crypt.Hash.Sha512Sum.Hash(System.Byte[],System.String)">
            <summary>
            Hashes a Sha512 of byte[]
            </summary>
            <param name="bytes"><see cref="!:byte[]">byte[] bytes</see></param>
            <param name="fileName">optional fileName to end</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Crypt.Hash.Sha512Sum.Hash(System.IO.Stream,System.String)" -->
        <member name="T:Area23.At.Framework.Core.Net.IpSocket.Listener">
            <summary>
            Net.IpSocket.Listener creates a server socket and listen and accept multi threaded connections
            When using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener"/> as server, you must use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender"/> as client,
            when using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Listener"/> as server, you should use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Sender"/> as client.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.Listener.#ctor(System.Net.IPAddress)">
            <summary>
            constructs a listening at <see cref="P:Area23.At.Framework.Core.Net.IpSocket.Listener.ServerAddress"/> via <see cref="P:Area23.At.Framework.Core.Net.IpSocket.Listener.ServerEndPoint"/> bound <see cref="P:Area23.At.Framework.Core.Net.IpSocket.Listener.ServerSocket"/>
            </summary>
            <param name="connectedIpIfAddr"><see cref="P:Area23.At.Framework.Core.Net.IpSocket.Listener.ServerAddress"/></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.Listener.HandleClientRequest(System.Object,System.EventArgs)">
            <summary>
            HandleClientRequest - handles client request
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.IpSocket.Sender">
            <summary>
            IpSocket.Sender encapsulation of tcp ipv46 sender 
            When using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener"/> as server, you must use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender"/> as client,
            when using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Listener"/> as server, you should use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Sender"/> as client.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.Sender.Send(System.Net.IPAddress,System.String,System.Int32)">
            <summary>
            Send
            </summary>
            <param name="serverIp">server ip address</param>
            <param name="msg">msg to send</param>
            <param name="serverPort">server port (default 7777)</param>
            <returns>client address as string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.Sender.SendAsync(System.Net.IPAddress,System.String,System.Int32)">
            <summary>
            SendAsync
            </summary>
            <param name="serverIp">server ip address</param>
            <param name="msg">msg to send</param>
            <param name="serverPort">server port (default 7777)</param>
            <returns><see cref="!:Task&lt;object&gt;"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener">
            <summary>
            Net.IpSocket.SockTcpListener creates a server socket and listen and accept multi threaded connections
            When using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener"/> as server, you must use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender"/> as client,
            when using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Listener"/> as server, you should use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Sender"/> as client.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener.#ctor(System.Net.IPAddress)">
            <summary>
            constructs a listening at <see cref="P:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener.ServerAddress"/> via <see cref="P:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener.ServerEndPoint"/> bound <see cref="P:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener.ServerSocket"/>
            </summary>
            <param name="connectedIpIfAddr"><see cref="P:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener.ServerAddress"/></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener.HandleClientRequest(System.Object,System.EventArgs)">
            <summary>
            HandleClientRequest - handles client request
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender">
            <summary>
            IpSocket.SockTcpSender encapsulation of tcp ipv46 sender 
            When using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpListener"/> as server, you must use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender"/> as client,
            when using <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Listener"/> as server, you should use <see cref="T:Area23.At.Framework.Core.Net.IpSocket.Sender"/> as client.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender.Send(System.Net.IPAddress,System.String,System.Int32)">
            <summary>
            Send
            </summary>
            <param name="serverIp">server ip address</param>
            <param name="msg">msg to send</param>
            <param name="serverPort">server port (default 7777)</param>
            <returns>client address as string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.IpSocket.SockTcpSender.SendAsync(System.Net.IPAddress,System.String,System.Int32)">
            <summary>
            SendAsync
            </summary>
            <param name="serverIp">server ip address</param>
            <param name="msg">msg to send</param>
            <param name="serverPort">server port (default 7777)</param>
            <returns><see cref="!:Task&lt;object&gt;"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.NameService.DnsHelper">
            <summary>
            Dns Domain Name Service Helper
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.NameService.DnsHelper.GetHostEntryByHostName(System.String)">
            <summary>
            GetHostEntryByHostName gets an IPHostEntry for a dns hostname
            </summary>
            <param name="hostname">hostname</param>
            <returns><see cref="T:System.Net.IPHostEntry"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.NameService.DnsHelper.GetIpAddrsByHostName(System.String)">
            <summary>
            GetIpAddrsByHostName get all ip addresses except loopback for a dns hostname
            </summary>
            <param name="hostname">hostname</param>
            <returns><see cref="T:System.Collections.Generic.List`1">IEnumerable{IPAddress}</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.NameService.DnsHelper.GetHostNamesByHostName(System.String)">
            <summary>
            GetDnsHostNamesByHostName gets official reverse lookup hostname for a hostname
            </summary>
            <param name="hostname"></param>
            <returns><see cref="!:IList&lt;string&gt;"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.NetworkAddresses">
            <summary>
            NetworkAddresses provides several members to get all local network addresses (except loopback)
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.NetworkAddresses.GetConnectedIpAddresses(System.Collections.Generic.List{System.Net.IPAddress})">
            <summary>
            GetConnectedIpAddresses gets connected IPAddress list.
            </summary>
            <param name="serverIps"><see cref="T:System.Collections.Generic.List`1"/></param>
            <returns><see cref="T:System.Collections.Generic.List`1"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.NetworkAddresses.GetConnectedIpAddressesAsync(System.Collections.Generic.List{System.Net.IPAddress})">
            <summary>
            GetConnectedIpAddressesAsync
            </summary>
            <param name="serverIps">serverIPs List to connect and verify, if connection is possible through</param>
            <returns><see cref="!:Task&lt;List&lt;IPAddress&gt;&gt;"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.NetworkAddresses.GetIpAddresses">
            <summary>
            GetIpAddresses gets all IPAddresses except loopback adapter
            </summary>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Net.NetworkAddresses.GetIpAddresses(System.Net.Sockets.AddressFamily)" -->
        <member name="M:Area23.At.Framework.Core.Net.NetworkAddresses.GetMacAddress">
            <summary>
            GetMacAddress returns Mac Address
            </summary>
            <returns><see cref="T:System.Collections.Generic.IList`1"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.WebHttp.HttpClientRequest">
            <summary>
            HttpClientRequest encapsulation
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Net.WebHttp.TcpClientWebRequest">
            <summary>
            <see cref="T:Area23.At.Framework.Core.Net.WebHttp.TcpClientWebRequest"/> performs web request raw on tcp socket 
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.TcpClientWebRequest.MakeWebRequest(System.Net.IPAddress,System.Collections.Generic.List{System.Net.IPAddress}@,System.Int32)">
            <summary>
            MakeWebRequest
            </summary>
            <param name="serverIp">server ip address</param>
            <param name="serverPort">server port (default 80)</param>
            <returns>client address as string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.TcpClientWebRequest.MakeWebRequestAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            MakeWebRequestAsync
            </summary>
            <param name="serverIp">server ip address</param>
            <param name="serverPort">server port (default 80)</param>
            <returns><see cref="!:Task&lt;object&gt;"/></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Net.WebHttp.WebClientRequest" -->
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.WebClientRequest.#cctor">
            <summary>
            static constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Net.WebHttp.WebClientRequest.DownloadString(System.String,System.String,System.String,System.Text.Encoding)" -->
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.WebClientRequest.ExternalClientIpFromServer(System.String,System.Text.Encoding)">
            <summary>
            ExternalClientIpFromServer gets external network ip for client from server
            </summary>
            <param name="url">default: https://cqrxs.eu/net/R.aspx https://area23.at/net/R.aspx</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/></param>
            <returns>external official gateway <see cref="T:System.Net.IPAddress">ip address</see> of client</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.WebClientRequest.PostMessage(System.String,System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            PostMessage posts message via <see cref="M:System.Net.WebClient.UploadString(System.String,System.String)"/>
            </summary>
            <param name="msg"></param>
            <param name="url"></param>
            <param name="hostname"></param>
            <param name="serverIp"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Net.WebHttp.WebServiceSoap" -->
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.WebServiceSoap.#cctor">
            <summary>
            static constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.WebServiceSoap.ExternalClientIpFromServer">
            <summary>
            ExternalClientIpFromServer gets external network ip for client from server
            </summary>
            <returns>external official gateway <see cref="T:System.Net.IPAddress">ip address</see> of client</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Net.WebHttp.WebServiceSoap.ExternalClientIpv6FromServer">
            <summary>
            ExternalClientIpv6FromServer gets external network ip for client from server
            </summary>
            <returns>external official gateway <see cref="T:System.Net.IPAddress">ip address</see> of client</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Properties.Resource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.app_name">
            <summary>
              Looks up a localized string similar to Area23.At.Framework.Library.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.BitmapAbout">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.build_with">
            <summary>
              Looks up a localized string similar to VisualStudio 2022 C# 4.8.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.F40">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.F45">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.fortune_u8">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.github_uri">
            <summary>
              Looks up a localized string similar to https://github.com/heinrichelsigan/area23.at/.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.help_text">
             <summary>
               Looks up a localized string similar to &lt;h1&gt;Area23.At.Framework.Library&lt;/h1&gt;
            &lt;p&gt;C# .Net Samples for apache2 mod_mono
            by Heinrich Elsigan (&lt;a href=&quot;mailto:he@area23.at&quot;&gt;heinrich.elsigan@area23.at&lt;/a&gt;).
            &lt;/p&gt;
            &lt;hr /&gt;
            Code is open source under GPL 3 and publicly accessible via &lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; repository &lt;a href=&quot;https://github.com/heinrichelsigan/area23.at/&quot; target=&quot;_blank&quot;&gt;github.com/heinrichelsigan/area23.at&lt;/a&gt;.
            &lt;br /&gt;.
             </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageAesArrow">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageAesArrowHover">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageCar">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageClickToUpload">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageDeCrypt">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageEnCrypt">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageFile">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageHash">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageKey">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.ImageSkull">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.json_sample0">
            <summary>
              Looks up a localized string similar to { 
            	&quot;quiz&quot;: { 
            		&quot;sport&quot;: { 
            			&quot;q1&quot;: { 
            				&quot;question&quot;: &quot;Which one is correct team name in NBA?&quot;, 
            					&quot;options&quot;: [ 
            						&quot;New York Bulls&quot;, 
            							&quot;Los Angeles Kings&quot;, 
            							&quot;Golden State Warriros&quot;, 
            							&quot;Huston Rocket&quot; 
            						], 
            					&quot;answer&quot;: &quot;Huston Rocket&quot; 
            				} 
            			}, 
            		&quot;maths&quot;: { 
            			&quot;q1&quot;: { 
            				&quot;question&quot;: &quot;5 + 7 = ?&quot;, 
            					&quot;options&quot;: [ 
            						&quot;10&quot;, 
            						&quot;11&quot;, 
            						&quot;12&quot;, 
            						&quot;13&quot; 
            					], 
            					&quot;answer&quot;: &quot;12&quot; 
            			}, 
            			&quot;q2&quot;: { 
            [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.json_sample1">
            <summary>
              Looks up a localized string similar to .
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.M0Rlc0l2">
            <summary>
              Looks up a localized string similar to fcKZpNSKLTs=.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.Q0FTVExF">
            <summary>
              Looks up a localized string similar to MEJBQjUxMEJBQjUxMEJBQjUxMEJBQjUxMEJBQjUwQkE=.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.Qk9VTkNF">
            <summary>
              Looks up a localized string similar to GvJd0SRyg3AcTF4Sidyrn/nJM1BNUJqKms19FZKx1Z4=.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.QWVzS2V5">
            <summary>
              Looks up a localized string similar to 0ersgfaO/uP7+HrpTwZjU9VoyobLofw7KvwCAcOVMRc=.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.QWVzSXY0">
            <summary>
              Looks up a localized string similar to 6pU0BotI3zzF0cWKz56bkQ==.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.RGVzS2V5">
            <summary>
              Looks up a localized string similar to C6S5DegwbQopnitJnAu/g4BXa0M32ZGZ.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.version_name">
            <summary>
              Looks up a localized string similar to v2.25.321.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Properties.Resource.wiki_uri">
            <summary>
              Looks up a localized string similar to https://github.com/heinrichelsigan/area23.at/.
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Static.Constants">
            <summary>
            static Constants including static application settings
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.Constants.AppLogFile">
            <summary>
            AppLogFile - logfile with <see cref="!:Framework.Library.Extensions.Area23Date(DateTime)"/> prefix
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.Constants.DateArea23Seconds">
            <summary>
            UT DateTime @area23.at including seconds
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.Constants.DateArea23">
            <summary>
            UTC DateTime Formated
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.Constants.DateFile">
            <summary>
            UTC DateTime File Prefix
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Constants.AppSettingsValueByKey(System.String)">
            <summary>
            AppSettingsValueByKey 
            </summary>
            <param name="key">key to lookup up in appsettings key value collection</param>
            <returns><see cref="T:System.String"/> AppSettingsValue</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Static.Extensions">
            <summary>
            Static extension methods Area23.At.Framework.Core
            
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.IsRoundNumber(System.Double)">
            <summary>
            <see cref="T:System.Double"/>.IsRoundNumber() extension methods: checks, if a double is a round number
            </summary>
            <param name="d">double to check</param>
            <returns>true, if it's integer number</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToLong(System.Double)">
            <summary>
            <see cref="T:System.Double"/>.ToLong() extension methods: converts a double to a long <see cref="T:System.Int64"/>
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.IsNan(System.Double)">
            <summary>
            <see cref="T:System.Double"/>.IsNan() extension methods: checks, if a double is not a number
            </summary>
            <param name="d">double to check</param>
            <returns>true, if dounble is not a number, otherwise false</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.Area23Date(System.DateTime)">
            <summary>
            <see cref="T:System.DateTime"/>.Area23Date() extension method: formats <see cref="T:System.DateTime"/>.ToString("yyyy-MM-dd")
            </summary>
            <param name="dateTime"><see cref="T:System.DateTime"/></param>
            <returns>formatted date <see cref="T:System.String"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.Area23DateTime(System.DateTime)">
            <summary>
            <see cref="T:System.DateTime"/>.Area23DateTime() extension method: formats <see cref="T:System.DateTime"/>.ToString("yyyy-MM-dd HH:mm")
            </summary>
            <param name="dateTime"><see cref="T:System.DateTime"/></param>
            <returns>formatted date time <see cref="T:System.String"/> </returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.Area23DateTimeWithSeconds(System.DateTime)">
            <summary>
            <see cref="T:System.DateTime"/>.Area23DateTimeWithSeconds() extension method: formats <see cref="T:System.DateTime"/>.ToString("yyyy-MM-dd_HH:mm:ss")
            </summary>
            <param name="dateTime">d</param>
            <returns><see cref="T:System.String"/> formatted date time including seconds</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.Area23DateTimeWithMillis(System.DateTime)">
            <summary>
            <see cref="T:System.DateTime"/>.Area23DateTimeWithMillis() extension method: formats <see cref="T:System.DateTime"/>.ToString("yyyyMMdd_HHmmss_milis")
            </summary>
            <param name="dateTime"><see cref="T:System.DateTime"/></param>
            <returns>formatted date time <see cref="T:System.String"/> </returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToByteArray(System.IO.Stream)">
            <summary>
            <see cref="T:System.IO.Stream"/>.ToByteArray() extension method: converts <see cref="T:System.IO.Stream"/> to <see cref="!:byte[]"/> array
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> which static methods are now extended</param>
            <returns>binary <see cref="!:byte[]">byte[] array</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.GetImageMimeType(System.Byte[])">
            <summary>
            <see cref="!:byte[]"/>.GetImageMimeType() extension method: auto detect mime type of an image inside an binary byte[] array
            via <see cref="M:System.Drawing.Imaging.ImageCodecInfo.GetImageEncoders"/> <seealso cref="M:System.Drawing.Imaging.ImageCodecInfo.GetImageDecoders"/>
            </summary>
            <param name="bytes">binary <see cref="!:byte[]">byte[] array</see></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ArrayIndexOf(System.Byte[],System.Byte)">
            <summary>
            <see cref="!:byte[]"/>.ArrayIndexOf(byte value) extension method: gets the first index of specified byte value
            </summary>
            <param name="bytes">byte[] to search</param>
            <param name="value">byte to find</param>
            <returns>index in array if found, otherwise -1</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToFile(System.Byte[],System.String,System.String,System.String)">
            <summary>
            <see cref="!:byte[]"/>.ToFile(string filePath, string fileName, string fext) extension method: writes a byte array to a file
            </summary>
            <param name="bytes"><see cref="!:byte[]"/></param>
            <param name="filePath">filesystem path</param>
            <param name="fileName">filename</param>
            <param name="fext">file extension</param>
            <returns>full file system path to new written file in case of success, on error simply null</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToHexString(System.Byte[])">
            <summary>
            <see cref="!:byte[]"/>.ToHexString() extension method: converts byte[] to HexString
            </summary>
            <param name="bytes">Array of <see cref="T:System.Byte"/></param>
            <returns>hexadecimal string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.FindBytes(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            <see cref="!:byte[]"/>.FindBytes extension method: searches hayStack for the first occurence of needle, 
            FindBytes uses static equivalent <see cref="M:Area23.At.Framework.Core.Static.Extensions.BytesBytes(System.Byte[],System.Byte[],System.Int32)"/> 
            </summary>
            <param name="hayStack">byte[] of haystack to search through</param>
            <param name="needle">byte[] of needle to find</param>        
            <param name="matchBytes">match the only first matchBytes of needle, -1 for all bytes</param>
            <returns>index of first byte of matching needle in haystack</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.BytesBytes(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            BytesBytes static method: searches hayStack for the first occurence of needle, 
            BytesBytes was inspired by unix posix c function strstr 
            </summary>
            <param name="hayStack">byte[] of haystack to search through</param>
            <param name="needle">byte[] of needle to find</param>        
            <param name="matchBytes">match the only first matchBytes of needle, -1 for all bytes</param>
            <returns>index of first byte of matching needle in haystack</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.TarBytes(System.Byte[],System.Byte[][])">
            <summary>
            <see cref="!:byte[]"/>.TarBytes extension method: tars 
            </summary>
            <param name="baseBytes">base byte array</param>
            <param name="bytesToAdd">more byte arrays</param>
            <returns>large tared byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.TarBytes(System.Byte[][])">
            <summary>
            TarBytes static method: tars all parameters of bytes array to one large byte array
            </summary>
            <param name="bytesToAdd">one up to many byte arrays</param>
            <returns>large tared byte array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.FromHexString(System.String)">
            <summary>
            <see cref="T:System.String"/>.FromHexString() extension method: converts hexadecimal string to byte[]
            </summary>
            <param name="hexString">hexadecimal string</param>
            <returns><see cref="!:byte[]">byte[]</see> Array of <see cref="T:System.Byte"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.Base64ToStream(System.String)">
            <summary>
            <see cref="T:System.String"/>.Base64ToStream() extension method: converts base64 string to stream
            </summary>
            <param name="base64">base64 encoded string</param>
            <returns>MemoryStream</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.Base64ToImage(System.String)">
            <summary>
            <see cref="T:System.String"/>.Base64ToImage() extension method: converts base64 string to an image
            </summary>
            <param name="base64">base64 encoded string</param>
            <returns>Image?</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.FromHtmlToColor(System.String)">
            <summary>
            <see cref="T:System.String"/>.FromHtmlToColor() extension methods: transforms hex #rrggbb string into <see cref="T:System.Drawing.Color"/>
            </summary>
            <param name="htmlRGBString"><see cref="T:System.String"/> to transform</param>
            <returns><see cref="T:System.Drawing.Color"/></returns>
            <exception cref="T:System.ArgumentException">invalid argument exception, in case of malformatted string</exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.GetExtensionFromFileString(System.String)">
            <summary>
            <see cref="T:System.String"/>.<see cref="M:Area23.At.Framework.Core.Static.Extensions.GetExtensionFromFileString(System.String)"/> Extension method
            </summary>
            <param name="fileName">fileName to process</param>
            <returns>extension of fileName</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.GetSubStringByPattern(System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.StringComparison)">
            <summary>
            <see cref="T:System.String"/>.<see cref="M:Area23.At.Framework.Core.Static.Extensions.GetSubStringByPattern(System.String,System.String,System.Boolean,System.String,System.String,System.Boolean,System.StringComparison)"/> Extension method 
            gets a substring beginning with patternStart and ending with patternEnd
            </summary>
            <param name="main">string to transform</param>
            <param name="patternStart">start pattern for substring, 
            if <see cref="M:System.String.Contains(System.String,System.StringComparison)">main.Contains(patternStart, comparasionType)</see>,
            so that int firstIndex = <see cref="M:System.String.IndexOf(System.String)">main.IndexOf(patternStart)</see> >= 0,
            then substring will start at <see cref="M:System.String.Substring(System.Int32)">main.Substring(firstIndex)</see>
            </param>
            <param name="firstIndex">default <see cref="!:true"/>, 
            if <see cref="!:true"/>, then first occurence in main <see cref="M:System.String.IndexOf(System.String)">main.IndexOf(patternStart)</see> will be executed, 
            otherwise if <see cref="!:false"/>, then <see cref="M:System.String.LastIndexOf(System.String)">main.LastIndexOf(patternStart)</see> will be executed.
            </param>
            <param name="markStartEnd">if <see cref="!:!string.IsNullOrEmpty(string?)">!string.IsNullOrEmpty(markStartEnd)</see> 
            then start position of substring will be set to <see cref="!:string.IndexOf(string)>">string.IndexOf(markStartEnd)</see>
            </param>
            <param name="patternEnd">end pattern for substring, <see cref="M:System.String.LastIndexOf(System.String)">main.IndexOf(patternEnd)</see></param>
            <param name="lastIndex">default <see cref="!:false"/>
            if <see cref="!:true"/>, then last occurence <see cref="M:System.String.LastIndexOf(System.String)">main.LastIndexOf(patternEnd)</see> will be executed,
            otherwise if <see cref="!:false"/>, then first occurence in main <see cref="M:System.String.IndexOf(System.String)">main.IndexOf(patternEnd)</see> will be executed. 
            </param>
            <param name="comparasionType">
            <see cref="T:System.StringComparison">comparasionType</see> is set default to <see cref="F:System.StringComparison.CurrentCulture"/>
            </param>
            <returns><see cref="T:System.String">substring</see>, if no substring could be extracted, then <see cref="F:System.String.Empty"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToLogMsg(System.Exception)">
            <summary>
            <see cref="T:System.Exception"/>.ToLogMsg() extension method: formats an exception to a well formatted logging message
            </summary>
            <param name="exc">the <see cref="T:System.Exception">exception</see></param>
            <returns><see cref="T:System.String">logMsg</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.FromHtml(System.Drawing.Color,System.String)">
            <summary>
            <see cref="T:System.Drawing.Color"/>.FromHtml(string hex) extension method: gets color from hexadecimal rgb string html standard
            </summary>
            <param name="color">System.Drawing.Color.FromHtml(string hex) extension method</param>
            <param name="hex">hexadecimal rgb string with starting #</param>
            <returns>Color, that was defined by hexadecimal html standarized #rrggbb string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.FromXrgb(System.Drawing.Color,System.String)">
            <summary>
            <see cref="T:System.Drawing.Color"/>.FromXrgb(string hex) extension method: gets color from hexadecimal rgb string
            </summary>
            <param name="color">System.Drawing.Color.FromXrgb(string hex) extension method</param>
            <param name="hex">hexadecimal rgb string with starting #</param>
            <returns>Color, that was defined by hexadecimal rgb string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.FromRGB(System.Drawing.Color,System.Byte,System.Byte,System.Byte)">
            <summary>
            <see cref="T:System.Drawing.Color"/>.FromRGB(byte r, byte g, byte b) extension method: gets color from R G B
            </summary>
            <param name="color">System.Drawing.Color.FromXrgb(string hex) extension method</param>
            <param name="r">red byte</param>
            <param name="g">green byte</param>
            <param name="b">blue byte</param>
            <returns>Color, that was defined by hexadecimal rgb string</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToXrgb(System.Drawing.Color)">
            <summary>
            <see cref="T:System.Drawing.Color"/>.ToXrgb() extension method: converts current color to hex string 
            </summary>
            <param name="color">current color</param>
            <returns>hexadecimal #rrGGbb string with leading # character</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.IsInLevenSteinDistance(System.Drawing.Color,System.Drawing.Color,System.Int32)">
            <summary>
            <see cref="T:System.Drawing.Color"/>.IsInLevenSteinDistance(Color colorCompare) extension method: finds out, if colorSrc and colorCompare are inside Levenstein distance
            </summary>
            <param name="colorSrc">source <see cref="T:System.Drawing.Color"/></param>
            <param name="colorCompare"><see cref="T:System.Drawing.Color"/> to compare with</param>
            <param name="levenSteinDelta">the absolute distance between to colors to tolerate</param>
            <returns>true, if both colors are inside Levenstein distance</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.SaveRawToMemoryStream(System.Drawing.Image,System.Drawing.Imaging.ImageFormat,System.Nullable{System.Guid}@)">
            <summary>
            <see cref="T:System.Drawing.Image"/>.SaveRawToMemoryStream(ImageFormat imageFormat, out Guid? g) extension method: 
            saves an Image to <see cref="T:System.IO.MemoryStream"/> and return <see cref="T:System.Guid"/> of <see cref="T:System.Drawing.Imaging.ImageFormat"/> as out parameter
            </summary>
            <param name="img"><see cref="T:System.Drawing.Image"/> to be processed by Exentsion Method</param>
            <param name="imageFormat"><see cref="T:System.Drawing.Imaging.ImageFormat"/></param>
            <param name="g"><see cref="T:System.Guid">out Guid g</see></param>
            <returns><see cref="T:System.IO.MemoryStream"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToByteArray(System.Drawing.Image)">
            <summary>
            <see cref="T:System.Drawing.Image"/>.ToByteArray() extension method: converts <see cref="T:System.Drawing.Image"/> to byte array
            </summary>
            <param name="img">this <see cref="T:System.Drawing.Image"/></param>
            <returns><see cref="!:byte[]?"/> array</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ToBase64(System.Drawing.Image)">
            <summary>
            <see cref="T:System.Drawing.Image"/>.ToBase64() extension method: converts <see cref="T:System.Drawing.Image"/> to base64 string
            </summary>
            <param name="img">this <see cref="T:System.Drawing.Image"/></param>
            <returns>base64 encoded <see cref="!:string?"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.IsValidXml(System.String)">
            <summary>
            IsValidXml extension method, that verifies if a string is a valid xml serialization
            </summary>
            <param name="xml">this <see cref="T:System.String">string xml</see> to xml validate</param>
            <returns>true, if it's a valid serialized xml string, otherwise false</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.IsValidJson(System.String)">
            <summary>
            Extension Method, that verifies if a string is a valid json serialization
            </summary>
            <param name="strInput">this <see cref="T:System.String">string input</see> to json validate</param>
            <returns>true, if it's a valid serialized json string, otherwise false</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.ReverseToString``1(System.Collections.Generic.Stack{``0})">
            <summary>
            <see cref="T:System.Collections.Generic.Stack`1"/>.ReverseToString<typeparamref name="T"/> extension method: reverses a objects in a stack to a string
            </summary>      
            <typeparam name="T">type parameter for generic <see cref="T:System.Collections.Generic.Stack`1"/></typeparam>
            <param name="stack">a generic  <see cref="T:System.Collections.Generic.Stack`1">Stack</see></param>  
            <returns>a string concatenation of reversed (fifoed) stack</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Extensions.SwapTPositions``1(``0[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            <see cref="!:T"/>.SwapTPositions&lt;<typeparamref name="T"/>&gt;(this <typeparamref name="T"/>[] tarray, .. extensions method
            Swaps values of two positions inside a generic Array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tarray">generic array</param>
            <param name="posA">position A of array</param>
            <param name="posB">position B of array</param>
            <param name="exceptionOnNullable">if indices points to null value field, throw exception</param>
            <returns>swapped T generic array</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Static.Extensions.ArrayIndexOf``1(``0[],``0,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Static.Extensions.FirstIndexOf``1(``0[],``0)" -->
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Static.Extensions.LastIndexOf``1(``0[],``0)" -->
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Static.Extensions.IndicesOf``1(``0[],``0)" -->
        <member name="T:Area23.At.Framework.Core.Static.JsonHelper">
            <summary>
            JsonHelper class for reading and writing json serialized store file.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Static.LibPaths" -->
        <member name="M:Area23.At.Framework.Core.Static.LibPaths.#cctor">
            <summary>
            static constructor
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.LibPaths.SystemDirPath">
            <summary>
            SystemDirPath return system directory path, 
            if defined in App.Config, 
            otherwise applcation directory of base exe.
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.LibPaths.SystemDirResPath">
            <summary>
            SystemDirResPath returns path to subdirector <see cref="F:Area23.At.Framework.Core.Static.Constants.RES_DIR"/> of base directory <see cref="P:Area23.At.Framework.Core.Static.LibPaths.SystemDirPath"/>.
            If subdirectory <see cref="F:Area23.At.Framework.Core.Static.Constants.RES_DIR"/> will be created, if it not allready exist inside directory <see cref="P:Area23.At.Framework.Core.Static.LibPaths.SystemDirPath"/>.        
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.LibPaths.SystemDirLogPath">
            <summary>
            SystemDirLogPath gets the default full path to logfile in file system
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.LibPaths.GetLogFilePath(System.String)">
            <summary>
            GetLogFilePath - gets individual named logfile with substring appName
            </summary>
            <param name="appName">application name to customize logfile name</param>
            <returns>Full file path to log file in file system</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Static.MimeType">
            <summary>
            MimeType gets mime type out of content byte[] (and filename) by MIT magick cookie
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.MimeType.GetMimeType(System.Byte[],System.String)">
            <summary>
            GetMimeType
            </summary>
            <param name="file"><see cref="!:byte[]">byte[] binary array</see></param>
            <param name="fileName">save filename</param>
            <returns>detected mime type by binary byte pattern, 
            if no specific mime type detect => default application/octet-stream</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.MimeType.GetFileExtForMimeTypeApache(System.String)">
            <summary>
            GetFileExtForMimeTypeApache
            </summary>
            <param name="mimeString">Mime type string in format genericType/specificType, e.g.:
            image/bmp
            image/gif
            image/x-icon
            image/jpeg
            audio/mpeg
            audio/ogg
            application/msword
            </param>
            <returns>extension based on windows / dos rules with 3 <see cref="T:System.Char"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Static.ProcessCmd">
            <summary>
            ProcessCmd static class for running an executable or processing shell command
            <see cref="!:https://github.com/heinrichelsigan/area23.at/blob/main/Framework/Library/ProcessCmd.cs">ProcessCmd.cs at github.com/heinrichelsigan</see>
            ProcessCmd class is free software; 
            you can redistribute it and/or modify it under the terms of the GNU Library General Public License 
            aspublished by the Free Software Foundation; 
            either <seealso cref="!:https://www.gnu.org/licenses/old-licenses/gpl-2.0.html">version 2</seealso> 
            of the License, or (at your option) any later version.
            See the GNU Library General Public License for more details.    
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.ProcessCmd.Execute(System.String,System.String,System.Boolean)">
            <summary>
            Execute a binary or shell cmd
            </summary>
            <param name="filepath">full or relative filepath to executable</param>
            <param name="arguments">arguments passed to executable</param>
            <param name="useShellExecute">set Process.StartInfo.UseShellExecute</param>
            <returns>standard output of process pexecec it.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.ProcessCmd.Execute(System.String,System.String[],System.Boolean,System.Boolean)">
            <summary>
            Execute a binary or shell cmd
            </summary>
            <param name="cmdPath">full or relative filepath to executable</param>
            <param name="arguments"><see cref="!:string[]">string[] arguments</see> passed to executable</param>
            <param name="quoteArgs"><see cref="T:System.Boolean">bool quoteArgs</see> set each single argument under double quote, when passing it to cmdPath</param>
            <param name="useShellExecute"><see cref="T:System.Boolean">bool useShellExecute</see> true, when using system shell to execute cmdPath</param>
            <returns>Console output of executed command</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Area23.At.Framework.Core.Static.ResReader">
            <summary>
            ResReader a simple resource file resx reader
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.ResReader.GetValue(System.String,System.String)">
            <summary>
            GetValue gets string resource form language specific resource file 
            </summary>
            <param name="key">unique key (culture independent) to address resource string</param>
            <param name="langCode">two letter long iso language code</param>
            <returns>string in local language fetched from resource file</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.ResReader.GetRes(System.String,System.Globalization.CultureInfo)">
            <summary>
            GetRes gets string resource form language specific resource file 
            </summary>
            <param name="key">unique key (culture independent) to address resource string</param>
            <param name="ci">CultureInfo for currently used language</param>
            <returns>string in local language fetched from resource file</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.ResReader.GetStringFormated(System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            GetStringFormated gets a formated string from language specific resource file
            </summary>
            <param name="key">unique key (culture independent) to address resource string</param>
            <param name="ci">CultureInfo for currently used language</param>
            <param name="args">object[] arguments needed for <see cref="M:System.String.Format(System.String,System.Object[])"/></param>
            <returns>string in local language fetched from resource file</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Static.SLog" -->
        <member name="P:Area23.At.Framework.Core.Static.SLog.LogFile">
            <summary>
            LogFile
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.SLog.N23Log">
            <summary>
            Get the Logger
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Static.SLog.CheckedToday">
            <summary>
            static Checked today if logfiles and other needed resources exist for today
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.SLog.Log(System.String,System.String)">
            <summary>
            Log - static logging method
            </summary>
            <param name="msg">message to log</param>
            <param name="appName">application name</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.SLog.Log(System.Exception,System.String)">
            <summary>
            Log - static logging method
            </summary>
            <param name="exLog"><see cref="T:System.Exception"/> to log</param>
            <param name="appName">application name</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Static.SLog.Log(System.String,System.Exception,System.String)" -->
        <member name="M:Area23.At.Framework.Core.Static.SLog.#cctor">
            <summary>
            private static ctor of SLog
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Static.Utils" -->
        <member name="M:Area23.At.Framework.Core.Static.Utils.SwapT``1(``0@,``0@)">
            <summary>
            SwapT a generic swapper
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t0">refernce in t0, reference out t1</param>
            <param name="t1">efernce in t1, reference out t0</param>
            <returns>an array with 2 elements with original positions</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.SetNull(System.Object[])">
            <summary>
            Generic null setter for an array of objects
            </summary>
            <param name="os"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.SetNullT``1(``0[])">
            <summary>
            generic null setter for an array of T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ts"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.SerializeToXml``1(``0)">
            <summary>
            SerializeToXml gemeric to xml serialize
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t">object to serialize</param>
            <returns>xml serialized string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.DeserializeFromXml``1(System.String)">
            <summary>
            DeserializeFromXml generic T from xml deserializer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xml">sml serialized string</param>
            <returns>generic T</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.SerializeToJsonl``1(``0)">
            <summary>
            SerializeToJsonl gemeric to json serialize
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t">object to serialize</param>
            <returns>json serialized string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.DeserializeFromJson``1(System.String)">
            <summary>
            DeserializeFromJson generic deserialize a json serialized string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="json">json serialized string</param>
            <returns>generic object T</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.GetAllFields(System.Type)">
            <summary>
            Get all the fields of a class
            </summary>
            <param name="type">Type object of that class</param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.GetAllProperties(System.Type)">
            <summary>
            Get all properties of a class
            </summary>
            <param name="type">Type object of that class</param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.FromHtml(System.String)">
            <summary>
            FromHtml gets color from hexadecimal rgb string html standard
            static method Supu.Framework.Extensions.ColorFrom.FromHtml(string hex) 
            is an alternative to System.Drawing.Color.FromHtml(string hex) extension method
            </summary>
            <param name="hex">hexadecimal rgb string with starting #</param>
            <returns>Color, that was defined by hexadecimal html standarized #rrggbb string</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Static.Utils.FromXrgb(System.String)">
            <summary>
            FromXrgb gets color from hexadecimal rgb string
            static method Supu.Framework.Extensions.ColorFrom.FromXrgb(string hex) 
            is an alternative to System.Drawing.Color.FromXrgb(string hex) extension method
            </summary>
            <param name="hex">hexadecimal rgb string with starting #</param>
            <returns>Color, that was defined by hexadecimal rgb string</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Util.Area23EventArgs`1">
            <summary>
            Area23EventArgs generic event args
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Area23.At.Framework.Core.Util.Area23EventArgs`1.GenericTData">
            <summary>
            <typeparamref name="T">geneneric T type or class</typeparamref>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23EventArgs`1.#ctor(`0)">
            <summary>
            ctor Area23EventArgs
            </summary>
            <param name="genericTData">generic T data</param>
        </member>
        <member name="T:Area23.At.Framework.Core.Util.Area23Log">
            <summary>
            simple singelton logger via NLog
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Util.Area23Log.Logger">
            <summary>
            Get the Logger
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Util.Area23Log.CheckedToday">
            <summary>
            Checked today if logfiles and other needed resources exist
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Util.Area23Log.LogFile">
            <summary>
            LogFile
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.#ctor">
            <summary>
            private Singelton constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.#ctor(System.String)">
            <summary>
            private Singelton constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.InitNLog(System.String)">
            <summary>
            InitNLog init NLog configuration
            </summary>
            <param name="appName">application name</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.Log(System.String,System.Int32)">
            <summary>
            log - logs to NLog
            </summary>
            <param name="msg">debug msg to log</param>
            <param name="logLevel">log level: 0 for Trace, 1 for Debug, ..., 4 for Error, 5 for Fatal</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.Log(System.Exception,System.Int32)">
            <summary>
            log Exception
            </summary>
            <param name="ex">Exception ex to log</param>
            <param name="level">log level: 0 for Trace, 1 for Debug, ..., 4 for Error, 5 for Fatal</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.LogOriginMsg(System.String,System.String,System.Int32)">
            <summary>
            Log origin with message to NLog
            </summary>
            <param name="origin">origin of message</param>
            <param name="message">enabler message to log</param>
            <param name="level">log level: 0 for Trace, 1 for Debug, ..., 4 for Error, 5 for Fatal</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.Area23Log.LogOriginMsgEx(System.String,System.String,System.Exception,System.Int32)">
            <summary>
            Log origin with message and thrown exception to NLog
            </summary>
            <param name="origin">origin of message</param>
            <param name="message">logging <see cref="T:System.String">string message</see></param>
            <param name="ex">logging <see cref="T:System.Exception">Exception ex</see></param>
            <param name="level"><see cref="T:System.Int32">int log level</see>: 0 for Trace, 1 for Debug, ..., 4 for Error, 5 for Fatal</param>
        </member>
        <member name="T:Area23.At.Framework.Core.Util.GifEncoder">
            <summary>   
            This encoder is taken from <see cref="!:https://github.com/DataDink/Bumpkit" />
            <seealso cref="!:https://github.com/DataDink/Bumpkit/blob/master/BumpKit/BumpKit/GifEncoder.cs">GifEncoder.cs</seealso>
            <seealso cref="!:https://github.com/DataDink/Bumpkit?tab=Unlicense-1-ov-file">Unlicense license of DataDink/Bumpkit</seealso>
            Encodes multiple images as an animated gif to a stream. <br />
            ALWAYS ALWAYS ALWAYS wire this up   in a using block <br />
            Disposing the encoder will complete the file. <br />
            Uses default .net GIF encoding and adds animation headers.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.GifEncoder.#ctor(System.Drawing.Image,System.Nullable{System.Int32},System.Nullable{System.TimeSpan})">
            <summary>
            Encodes multiple images as an animated gif to a stream. <br />
            ALWAYS ALWAYS ALWAYS wire this in a using block <br />
            Disposing the encoder will complete the file. <br />
            Uses default .net GIF encoding and adds animation headers.
            </summary>
            <param name="stream">The stream that will be written to.</param>
            <param name="width">Sets the width for this gif or null to use the first frame's width.</param>
            <param name="height">Sets the height for this gif or null to use the first frame's height.</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Util.GifEncoder.AddFrame(System.Drawing.Image,System.Nullable{System.TimeSpan})">
            <summary>
            Adds a frame to this animation.
            </summary>
            <param name="img">The image to add</param>
            <param name="frameDelay">TimeSpan for delay</param>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.HWndInfo">
            <summary>
            HWndInfo - window handle class
            Thanks to <see href="https://github.com/dotnet">github.com/dotnet</see>,
            <see href="https://stackoverflow.com/">stackoverflow.com/</see>,
            <see href="https://www.pinvoke.net/">pinvoke.net</see> and
            <see cref="!:https://www.codeproject.com/">cpdeproject.com</see>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.HWndInfo.CloseWindow(System.IntPtr)">
            <summary>
            CloseWindow sends standard close message to window by handle
            </summary>
            <param name="hwnd">window handle</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.HWndInfo.FindChildWindow(System.IntPtr@,System.IntPtr,System.String,System.String)">
            <summary>
            FindChildWindow
            </summary>
            <param name="hWndChild">child window handle to find</param>
            <param name="hWndParent">parent window handle</param>
            <param name="className">Class Name</param>
            <param name="windowTitle">Window Title</param>
            <returns>child window handle to find</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Win32Api.HWndInfo.FindWindowHandle(System.String,System.String)" -->
        <member name="M:Area23.At.Framework.Core.Win32Api.HWndInfo.GetDesktopWindow">
            <summary>
            GetDesktopWindow => window handle of root desktop window
            </summary>
            <returns>window handle of root desktop window</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.HWndInfo.GetTopWindow(System.IntPtr)">
            <summary>
            GetTopWindow finds the top most window for a specific window
            </summary>
            <param name="hWnd">window handle</param>
            <returns>top most window handle</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.HWndInfo.WindowHandleBelongsTo(System.IntPtr,System.Int32)">
            <summary>
            Finds out, if window handle, belongs to process identifier
            </summary>
            <param name="bhWnd">window handle</param>
            <param name="bhPid">process identifier</param>
            <returns>true, if window handle belongs to process identifier</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.InternalErrorException">
            <summary>
            InternalError Exception derived from <see cref="T:System.ComponentModel.Win32Exception"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.InternalErrorException.#ctor">
            <summary>
            InternalErrorException parameterless constructor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.InternalErrorException.#ctor(System.String)">
            <summary>
            InternalErrorException constructor with simple msg
            </summary>
            <param name="msg"><see cref="T:System.String">string msg</see> a message to describe the <see cref="!:EnablerSpoolerException"/></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.InternalErrorException.#ctor(System.String,System.Exception)">
            <summary>
            InternalErrorException constructor with simple msg and innerException
            </summary>
            <param name="msg"><see cref="T:System.String">string msg</see> a message to describe the <see cref="!:EnablerSpoolerException"/></param>
            <param name="innerEx"><see cref="T:System.Exception">Exception innerEx</see> inner Exception, that was previously thrown</param>        
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper">
            <summary>
            NativeWrapper contain inner classes for User32, Kernel32 and GDI32 Windows Core API calls
            Thanks to <see href="https://github.com/dotnet">github.com/dotnet</see>,
            <see href="https://stackoverflow.com/">stackoverflow.com/</see>,
            <see href="https://www.pinvoke.net/">pinvoke.net</see> and
            <see cref="!:https://www.codeproject.com/">cpdeproject.com</see>
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.PROCESSINFOCLASS">
            <summary>
            enum PROCESSINFOCLASS 
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.eDesiredAccess">
            <summary>
            enum eDesiredAccess process accessing flags
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.COWAIT_FLAGS">
            <summary>
            Flags for CoWaitForMultipleHandles
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.COWAIT_FLAGS.COWAIT_NONE">
            <summary>
            Exit when a handle is signaled.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.COWAIT_FLAGS.COWAIT_WAITALL">
            <summary>
            Exit when all handles are signaled AND a message is received.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.COWAIT_FLAGS.COWAIT_ALERTABLE">
            <summary>
            Exit when an RPC call is serviced.
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.ProcessorArchitectures">
            <summary>
            Processor architecture values
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MAX_PATH">
            <summary>
            Default buffer size to use when dealing with the Windows API.
            </summary>
            <remarks>
            This member is intentionally not a constant because we want to allow
            unit tests to change it.
            </remarks>
        </member>
        <member name="P:Area23.At.Framework.Core.Win32Api.NativeWrapper.IsWindows">
            <summary>
            Gets a flag indicating if we are running under some version of Windows
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Win32Api.NativeWrapper.OSName">
            <summary>
            Gets a string for the current OS. This matches the OS env variable
            for Windows (Windows_NT).
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Win32Api.NativeWrapper.SystemInformation">
            <summary>
            System information, initialized when required.
            </summary>
            <remarks>
            Initially implemented as <see cref="T:System.Lazy`1"/>, but
            that's .NET 4+, and this is used in MSBuildTaskHost.
            </remarks>
        </member>
        <member name="P:Area23.At.Framework.Core.Win32Api.NativeWrapper.ProcessorArchitecture">
            <summary>
            Architecture getter
            </summary>
        </member>
        <member name="P:Area23.At.Framework.Core.Win32Api.NativeWrapper.ProcessorArchitectureNative">
            <summary>
            Native architecture getter
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.Kernel32">
            <summary>
            Helper class containing kernel32 functions
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.Kernel32.AttachConsole(System.Int32)">
            <summary>
            AttachConsole to Windows Form App
            </summary>
            <param name="dwProcessId"></param>
            <returns></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.GDI32">
            <summary>
            Helper class containing Gdi32 API functions
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.User">
            <summary>
            User class containing simplified User32 API functions with int instead of IntPtr
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.User32">
            <summary>
            Helper class containing User32 API functions
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.SafeProcessHandle">
            <summary>
            Wrap the intptr returned by OpenProcess in a safe handle.
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus">
            <summary>
            Contains information about the current state of both physical and virtual memory, including extended memory
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus._length">
            <summary>
            Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.MemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical
            memory that is in use (0 indicates no memory use and 100 indicates full memory use).
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.TotalPhysical">
            <summary>
            Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.AvailablePhysical">
            <summary>
            Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.TotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes. This is physical memory plus the
            size of the page file, minus a small overhead.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.AvailablePageFile">
            <summary>
            Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.TotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.AvailableVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.MemoryStatus.AvailableExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual
            address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.SecurityAttributes">
            <summary>
            Contains the security descriptor for an object and specifies whether
            the handle retrieved by specifying this structure is inheritable.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.SystemInformationData.ProcessorArchitectureType">
            <summary>
            Architecture as far as the current process is concerned.
            It's x86 in wow64 (native architecture is x64 in that case).
            Otherwise it's the same as the native architecture.
            </summary>
        </member>
        <member name="F:Area23.At.Framework.Core.Win32Api.NativeWrapper.SystemInformationData.ProcessorArchitectureTypeNative">
            <summary>
            Actual architecture of the system.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.SystemInformationData.ConvertSystemArchitecture(System.UInt16)">
            <summary>
            Convert SYSTEM_INFO architecture values to the internal enum
            </summary>
            <param name="arch"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.SystemInformationData.#ctor">
            <summary>
            Read system info values
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.SYSTEM_INFO">
            <summary>
            Structure that contain information about the system on which we are running
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.NativeWrapper.WIN32_FILE_ATTRIBUTE_DATA">
            <summary>
            Contains information about a file or directory; used by GetFileAttributesEx.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetLastWriteDirectoryUtcTime(System.String,System.DateTime@)">
            <summary>
            Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
            if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetShortFilePath(System.String)">
            <summary>
            Takes the path and returns the short path
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetLongFilePath(System.String)">
            <summary>
            Takes the path and returns a full path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetMemoryStatus">
            <summary>
            Retrieves the current global memory status.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetContentLastWriteFileUtcTime(System.String)">
            <summary>
            Get the last write time of the content pointed to by a file path.
            </summary>
            <param name="fullPath">Full path to the file in the filesystem</param>
            <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
            <remarks>
            This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
            See https://github.com/Microsoft/msbuild/issues/2052.
            </remarks>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.HResultSucceeded(System.Int32)">
            <summary>
            Did the HRESULT succeed
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.HResultFailed(System.Int32)">
            <summary>
            Did the HRESULT Fail
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.ThrowExceptionForErrorCode(System.Int32)">
            <summary>
            Given an error code, converts it to an HRESULT and throws the appropriate exception.
            </summary>
            <param name="errorCode"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.KillTree(System.Int32)">
            <summary>
            Kills the specified process by id and all of its children recursively.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetParentProcessId(System.Int32)">
            <summary>
            Returns the parent process id for the specified process.
            Returns zero if it cannot be gotten for some reason.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetChildProcessIds(System.Int32,System.DateTime)">
            <summary>
            Returns an array of all the immediate child processes by id.
            NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetCurrentDirectory">
            <summary>
            Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
            </summary>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.VerifyThrow(System.Boolean,System.String)">
            <summary>
            This method should be used in places where one would normally put
            an "assert". It should be used to validate that our assumptions are
            true, where false would indicate that there must be a bug in our
            code somewhere. This should not be used to throw errors based on bad
            user input or anything that the user did wrong.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.VerifyThrow(System.Boolean,System.String,System.Object)">
            <summary>
            Overload for one string format argument.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.VerifyThrow(System.Boolean,System.String,System.Object,System.Object)">
            <summary>
            Overload for two string format arguments.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Overload for three string format arguments.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Overload for four string format arguments.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.ThrowInternalError(System.String,System.Object[])">
            <summary>
            Throws InternalErrorException.
            This is only for situations that would mean that there is a bug in MSBuild itself.
            </summary>]
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.FormatString(System.String,System.Object[])">
             <summary>
             Formats the given string using the variable arguments passed in.
            
             PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
             the array of arguments -- do not call this method repeatedly in performance-critical scenarios
            
             Thread safe.
             </summary>
             <param name="unformatted">The string to format.</param>
             <param name="args">Optional arguments for formatting the given string.</param>
             <returns>The formatted string.</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.MsgWaitOne(System.Threading.WaitHandle)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.MsgWaitOne(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.MsgWaitOne(System.Threading.WaitHandle,System.Int32)">
            <summary>
            Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
            servicing COM calls from other threads.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetOEMCP">
            <summary>
            Gets the current OEM code page which is used by console apps
            (as opposed to the Windows/ANSI code page used by the normal people)
            Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
            that needs to be used for instance when writing to batch files
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.GetModuleFileName(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            Gets the fully qualified filename of the currently executing .exe
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.CoWaitForMultipleHandles(Area23.At.Framework.Core.Win32Api.NativeWrapper.COWAIT_FLAGS,System.Int32,System.Int32,System.IntPtr[],System.Int32@)">
            <summary>
            CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
            VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
            build thread which the main thread (blocked on BuildSubmission.Execute) must service.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.NativeWrapper.WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)">
            <summary>
            Really truly non pumping wait.
            Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
            single SafeHandles.
            </summary>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.ProcessCmd">
            <summary>
            ProcessCmd static class for running an executable or processing shell command
            <see cref="!:https://github.com/heinrichelsigan/area23.at/blob/main/Framework/Library/ProcessCmd.cs">ProcessCmd.cs at github.com/heinrichelsigan</see>
            ProcessCmd class is free software; 
            you can redistribute it and/or modify it under the terms of the GNU Library General Public License 
            aspublished by the Free Software Foundation; 
            either <seealso cref="!:https://www.gnu.org/licenses/old-licenses/gpl-2.0.html">version 2</seealso> 
            of the License, or (at your option) any later version.
            See the GNU Library General Public License for more details.    
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ProcessCmd.Execute(System.String,System.String,System.Boolean)">
            <summary>
            Execute a binary or shell cmd
            </summary>
            <param name="filepath">full or relative filepath to executable</param>
            <param name="args">arguments passed to executable</param>
            <param name="useShellExecute">set Process.StartInfo.UseShellExecute</param>
            <returns>standard output of process pexecec it.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ProcessCmd.Execute(System.String,System.String[],System.Boolean,System.Boolean)">
            <summary>
            Execute a binary or shell cmd
            </summary>
            <param name="cmdPath">full or relative filepath to executable</param>
            <param name="args"><see cref="!:string[]">string[] args</see> passed to executable</param>
            <param name="quoteArgs"><see cref="T:System.Boolean">bool quoteArgs</see> set each single argument under double quote, when passing it to cmdPath</param>
            <param name="useShellExecute"><see cref="T:System.Boolean">bool useShellExecute</see> true, when using system shell to execute cmdPath</param>
            <returns>Console output of executed command</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.Processes">
            <summary>
            Processes - a windows process Library using Win32 Api
            Thanks to <see href="https://github.com/dotnet">github.com/dotnet</see>,
            <see href="https://stackoverflow.com/">stackoverflow.com/</see>,
            <see href="https://www.pinvoke.net/">pinvoke.net</see> and
            <see cref="!:https://www.codeproject.com/">cpdeproject.com</see>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.ProcessRuns(System.Int32)">
            <summary>
            Checks if a certain process is currently running  
            </summary>
            <param name="pid">process identifier</param>
            <returns>true, if process <see cref="!:Process.GetP(pid)"/>with> </returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetProcessById(System.Int32)">
            <summary>
            GetProcessById gets the <see cref="T:System.Diagnostics.Process"/> by pid
            </summary>
            <param name="pid">process identifier</param>
            <returns><see cref="T:System.Diagnostics.Process"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetProcessByHwnd(System.IntPtr)">
            <summary>
            GetProcessByHwnd finds process belongig to a window handle
            </summary>
            <param name="hwnd">window handle</param>
            <returns><see cref="T:System.Diagnostics.Process"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetRunningProcessesByName(System.String)">
            <summary>
            GetRunningProcessesByName gets all running processes 
            </summary>
            <param name="processName">executable name</param>
            <returns><see cref="!:Process[]">Array of Process</see></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Win32Api.Processes.GetProcessByNameAndWindowTitle(System.String,System.String)" -->
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetParentProcessId(System.Int32)">
            <summary>
            Returns the parent process id for the specified process.
            Returns zero if it cannot be gotten for some reason.
            </summary>
            <param name="pid">process identifier</param>
            <returns>parent process identifier</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetParentProcessById(System.Int32)">
            <summary>
            GetParentProcessById gets parent process by pid
            </summary>
            <param name="pid">process identifier</param>
            <returns><see cref="T:System.Diagnostics.Process"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetChildIdNames(System.Int32,System.Boolean)">
            <summary>
            GetChildIdNames 
            </summary>
            <param name="pPid"><see cref="T:System.Int32"/> parent process identifier pPid</param>        
            <param name="addParent">true, if to add parent id and process name too, default false</param>
            <returns><see cref="!:Dictionary&lt;int, string&gt;"/> parent_child_ProcessMap</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.ListChildProcesses(System.Int32,System.Boolean)">
            <summary>
            ListChildProcesses list all child processes belonging to a parent process identifier pPid
            </summary>
            <param name="pPid"><see cref="T:System.Int32"/> parent process identifier pPid</param>
            <param name="addParent">true, if to add parent id and process name too, default false</param>
            <returns><see cref="!:Process[]"/> array of <see cref="T:System.Diagnostics.Process"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetChildPids(System.Int32,System.Boolean)">
            <summary>
            GetChildPids get an <see cref="!:int[]">int[] array</see> of all child process identifiers from a parent process indentifier
            </summary>
            <param name="pPid"><see cref="T:System.Int32"/> parent process identifier pPid</param>
            <param name="addParent">true, if to add parent id and process name too, default false</param>
            <returns><see cref="!:int[]"/> array with all child process id's</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.GetProcessOwnerById(System.Int32)">
            <summary>
            GetProcessOwnerById - gets process owning windows user, by process identifier
            </summary>
            <param name="pid">process identifier</param>
            <returns>user, that owns process</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.KillProcess(System.Int32,System.Boolean)">
            <summary>
            KillProcess - kills process with process identifier pid 
            </summary>
            <param name="pid"><see cref="T:System.Int32">int pid</see> process identifier</param>
            <param name="ignoreWin32SystemProcesses">if true, Win32 system processes and their childs will not be killed</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.KillTree(System.Int32)">
            <summary>
            Kills the specified process by id and all of its children recursively.
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Processes.KillProcessTree(System.Int32,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            KillProcessTree kill all child processes recursivly including parent process id
            </summary>
            <param name="pid">pid process identifier</param>        
            <param name="killParent">kill parent process (and not only childs) default to <see cref="!:true"/></param>
            <param name="psKilled">counter for processes already killed in current recursion tree</param>
            <param name="ignoreWin32SystemProcesses">if true, Win32 system processes and their childs will not be killed</param>
            <returns>number of processes totally killed in current recursive tree</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.RegistryAccessor">
            <summary>
            static windows registry accessor with synchronous and asynchronous members
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.RegistryAccessor.#cctor">
            <summary>
            static ctor
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.RegistryAccessor.GetRegistryEntry(Microsoft.Win32.RegistryHive,System.String,System.String)">
            <summary>
            GetRegistryEntry gets value for specified name from registry segment
            </summary>
            <param name="regHive">registry root hive</param>
            <param name="subKeyName">subKey in registry root hive segment</param>
            <param name="regName">unique name inside subKey registry segment</param>
            <returns>object value</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.RegistryAccessor.SetRegistryEntry(System.Object,Microsoft.Win32.RegistryHive,System.String,System.String)">
            <summary>
            SetRegistryEntry sets a value for a name in registry 
            </summary>        
            <param name="value">value to set</param>
            <param name="regHive">registry root hive</param>
            <param name="subKeyName">subKey in root hive registry segment</param>
            <param name="regName">name in subKey registry segment</param>
            <returns>void means nothing</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.RegistryAccessor.GetRegistryEntryAsync(Microsoft.Win32.RegistryHive,System.String,System.String)">
            <summary>
            GetRegistryEntryAsync async gets an registry name value inside subkey asynchronous
            </summary>
            <param name="regHive">registry root hive</param>
            <param name="subKeyName">registry subkey name</param>
            <param name="regName">registry name ref</param>
            <returns><see cref="!:Task&lt;object&gt;"/></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.RegistryAccessor.SetRegistryEntryAsync(System.Object,Microsoft.Win32.RegistryHive,System.String,System.String)">
            <summary>
            SetRegistryEntryAsync async sets object value in registry 
            </summary>
            <param name="value"><see cref="T:System.Object"/> value to set</param>
            <param name="regHive">registry root hive</param>
            <param name="subKeyName">registry subkey name</param>
            <param name="regName">registry name ref</param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.RegistryAccessor.AwaitTaskAsync``1(System.Threading.Tasks.Task{``0})">
            <summary>
            AwaitTaskAsync
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="task"></param>
            <returns><see cref="T:System.Threading.Tasks.Task`1"/></returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.ScreenCapture">
            <summary>
            Thanks to <see href="https://github.com/dotnet">github.com/dotnet</see>,
            <see href="https://stackoverflow.com/">stackoverflow.com/</see>,
            <see href="https://www.pinvoke.net/">pinvoke.net</see> and
            <see cref="!:https://www.codeproject.com/Articles/546006/Screen-Capture-on-Multiple-Monitors"/>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureScreen">
            <summary>
            CaptureScreen creates an Image object containing a screen shot of the entire desktop
            </summary>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureDesktopScreen">
            <summary>
            CaptureDesktopScreen creates an Image object containing a screen shot of the entire desktop
            </summary>
            <param name="filename"></param>
            <param name="format"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureAllDesktops">
            <summary>
            CaptureAllDesktops capture all existing windows desktop
            </summary>
            <returns>Image, that contains all windows desktop capture</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureAllWindows">
            <summary>
            Creates an Image object containing a screen shot of the entire desktop and child windows
            </summary>
            <returns>Array of Images</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureWindow(System.IntPtr)">
            <summary>
            Creates an Image object containing a screen shot of a specific window
            </summary>
            <param name="handle">The handle to the window. (In windows forms, this is obtained by the Handle property)</param>
            <returns>Image</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureAllScreen(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CaptureAllScreen capture screen section    
            </summary>
            <param name="x">x start postion to capture</param>
            <param name="y">y start postion to capture</param>
            <param name="width">full with of all screens</param>
            <param name="height">full height of all screens</param>
            <returns>Image, that contains all screen capture cutting</returns>        
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureWindowToFile(System.IntPtr,System.String,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Captures a screen shot of a specific window, and saves it to a file
            </summary>
            <param name="handle"></param>
            <param name="filename"></param>
            <param name="format"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureScreenToFile(System.String,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Captures a screen shot of the entire desktop, and saves it to a file
            </summary>
            <param name="filename"></param>
            <param name="format"></param>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.ScreenCapture.CaptureScreenAndAllWindowsToDirectory(System.String)">
            <summary>
            Captures a screen shot of the entire desktop and all child windows and saves it tó a directory
            </summary>
            <param name="directory"></param>
            <param name="format"></param>
        </member>
        <member name="T:Area23.At.Framework.Core.Win32Api.Threads">
            <summary>
            Threads - a windows Threads Library using Win32 Api
            Thanks to <see href="https://github.com/dotnet">github.com/dotnet</see>,
            <see href="https://stackoverflow.com/">stackoverflow.com/</see>,
            <see href="https://www.pinvoke.net/">pinvoke.net</see> and
            <see cref="!:https://www.codeproject.com/">cpdeproject.com</see>
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Threads.GetCurrentThreadId">
            <summary>
            Checks if a certain process is currently running  
            </summary>
            <param name="pid">process identifier</param>
            <returns>true, if process <see cref="!:Process.GetP(pid)"/>with> </returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Win32Api.Threads.GetThreadIdProcessId(System.IntPtr,System.UInt32@)">
            <summary>
            GetThreadIdProcessId gets threadId and processId by
            window handle
            </summary>
            <param name="hWnd"><see cref="T:System.IntPtr" /> window handle</param>
            <param name="upid">unsigned int process identifier</param>
            <returns>uint threadId</returns>
        </member>
        <member name="T:Area23.At.Framework.Core.Zfx.BZip2">
            <summary>
            static class BZip2 provides bzip2 and bunzip2 functionality
            </summary>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.BZip2.BZip(System.Byte[],System.Int32)">
            <summary>
            BZip transfdorms uncompressed <see cref="!:byte[]">byte[] inBytes</see> to <see cref="!:byte[]">bzip2 compressed (byte[])bytes</see>
            </summary>
            <param name="inBytes"> <see cref="!:byte[]">bytes</see> ready to compress</param>
            <param name="compressionLevel">level of compression: 
             1  ... for at least no compression, 
            4,5 ... for average compression
             9  ... for strongest bzip2 compression, generating smallest most compact output 
            </param>
            <returns><see cref="!:byte[]?">byte[] bzip2 compressed out bytes</see></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Zfx.BZip2.BZip2Stream(System.IO.MemoryStream,System.Boolean,System.Int32)" -->
        <member name="M:Area23.At.Framework.Core.Zfx.BZip2.BZip2Bytes(System.Byte[],System.Int32)">
            <summary>
            BZip2Bytes bzip2 <see cref="!:byte[]">byte[] inBytes</see> 
            and write bzip2 compressed data <see cref="!:byte[]">byte[] outBytes</see> 
            </summary>
            <param name="inBytes"><see cref="!:byte[]">byte[] inBytes, containing data to compress with bzip2</see></param>
            <param name="compressionLevel">level of compression: 
             1  ... for at least no compression, 
            4,5 ... for average compression
             9  ... for strongest bzip2 compression, generating smallest most compact output 
            </param>
            <returns><see cref="!:byte[]">byte[] outBytes</see> containing bzip2 compressed data of / from <see cref="!:byte[]">byte[] outBytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.BZip2.BZip2TextAndEncode(System.String,System.Int32,Area23.At.Framework.Core.Crypt.EnDeCoding.EncodingType)">
            <summary>
            BZips a string and returns it as hex16, hex32, base32, base64 (default) or uuencoded string
            </summary>
            <param name="inText"></param>
            <param name="compressionLevel"></param>
            <param name="encType"></param>
            <returns></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.BZip2.BUnZip(System.Byte[])">
            <summary>
            BUnZips compressed <see cref="!:byte[]">byte[] inBytes</see> 
            and returns the decompressed bunzipped <see cref="!:byte[]?" />.
            </summary>
            <param name="inBytes">compressed / bzipped <see cref="!:byte[]">byte[] inBytes</see></param>
            <returns>decompressed bunzipped <see cref="!:byte[]?">byte[]?</see></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Area23.At.Framework.Core.Zfx.BZip2.BUnZip2Stream(System.IO.MemoryStream,System.Boolean)" -->
        <member name="M:Area23.At.Framework.Core.Zfx.BZip2.BUnZip2Bytes(System.Byte[])">
            <summary>
            BUnZip2Bytes bunzips <see cref="!:byte[]">byte[] inBytes</see> and writes
            decompressed unzipped data to <see cref="!:byte[]">byte[] outBytes</see> 
            </summary>
            <param name="inBytes"><see cref="!:byte[]">byte[] inBytes, containing bzip2 compressed data</see></param>
            <returns><see cref="!:byte[]">byte[] outBytes</see> containing bunzipped / decompressed data from <see cref="!:byte[]">byte[] inBytes</see></returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.BZip2.BzFile(System.String,System.String@,System.String,System.Boolean,System.Int32)">
            <summary>
            BzFile bzips or bunzips a file
            </summary>
            <param name="inFile"><see cref="T:System.String">full (unc) filepath to file</see></param>
            <param name="outMessage">string with information, what happend</param>
            <param name="outFile"><see cref="T:System.String"/>full (unc) filepath to outfile,
            if keept empty, .bz2 will be added after compression and .bz|.bz2 will be removed after decompressing bzip'd file.</param>
            <param name="zip"><see cref="T:System.Boolean">(bool)true for bzip2, (bool)false for bunzip2 (bzip2 -d)</see></param>
            <param name="compressionLevel">level of compression: 
             1  ... for at least no compression, 
            4,5 ... for average compression
             9  ... for strongest bzip2 compression, generating smallest most compact output 
            </param>
            <returns><see cref="T:System.String">string name of processed (bzipped/bunzipped) file</see></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Area23.At.Framework.Core.Zfx.GZ" -->
        <member name="M:Area23.At.Framework.Core.Zfx.GZ.GZip(System.Byte[],System.Int32)">
            <summary>
            GZip directly, please use <see cref="!:GZipViaStream(byte[])"/>
            </summary>
            <param name="inBytes"><see cref="!:byte[]"/> inBytes</param>
            <param name="compressionLevel">level of compression: 
             1  ... for at least no compression, 
            4,5 ... for average compression
             9  ... for strongest bzip2 compression, generating smallest most compact output 
            </param>
            <returns><see cref="!:byte[]"/> outbytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.GZ.GZipStream(System.IO.MemoryStream)">
            <summary>
            GZipStream 
            </summary>
            <param name="inMem"><see cref="T:System.IO.MemoryStream"/> inMem</param>
            <returns><see cref="T:System.IO.MemoryStream"/> outMem</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.GZ.GUnZip(System.Byte[])">
            <summary>
            Please use <see cref="!:GUnZipViaStream(byte[])"/>
            </summary>
            <param name="inBytes"><see cref="!:byte[]"/> inBytes</param>
            <returns><see cref="!:byte[]"/> outbytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.GZ.GUnZipBytes(System.Byte[])">
            <summary>
            GUnZipViaStream
            </summary>
            <param name="inBytes"><see cref="!:byte[]"/> inBytes</param>
            <returns><see cref="!:byte[]"/> outbytes</returns>
        </member>
        <member name="M:Area23.At.Framework.Core.Zfx.GZ.GzFile(System.String,System.String@,System.String,System.Boolean,System.Int32)">
            <summary>
            
            </summary>
            <param name="inFile"></param>
            <summary>
            GzFile gzips or gunzips a file
            </summary>
            <param name="inFile"><see cref="T:System.String">full (unc) filepath to file</see></param>
            <param name="outMessage">string with information, what happend</param>
            <param name="outFile"><see cref="T:System.String"/>full (unc) filepath to outfile,
            if keept empty, .gz will be added after compression and .gz will be removed after decompressing gzip'd file.</param>
            <param name="zip"><see cref="T:System.Boolean">(bool)true for gzip, (bool)false for gunzip</see></param>
            <param name="compressionLevel">level of compression: 
             1  ... for at least no compression, 
            4,5 ... for average compression
             9  ... for strongest bzip2 compression, generating smallest most compact output 
            </param>
            <returns><see cref="T:System.String">string name of processed (gzipped/gunzipped) file</see></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
    </members>
</doc>
